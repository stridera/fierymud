#pragma once
/**
 * @file db_enums.hpp
 * @brief Database enum definitions auto-generated from Prisma schema.
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate_db_headers.py
 * Source: muditor/packages/db/prisma/schema.prisma
 * Generated: 2026-01-19T18:48:11.181090
 */

#include <optional>
#include <string_view>
#include <unordered_map>

namespace db {

// ============================================================================
// Room System
// ============================================================================

enum class Sector {
    Structure = 0,
    City = 1,
    Field = 2,
    Forest = 3,
    Hills = 4,
    Mountain = 5,
    Shallows = 6,
    Water = 7,
    Underwater = 8,
    Air = 9,
    Road = 10,
    Grasslands = 11,
    Cave = 12,
    Ruins = 13,
    Swamp = 14,
    Beach = 15,
    Underdark = 16,
    Astralplane = 17,
    Airplane = 18,
    Fireplane = 19,
    Earthplane = 20,
    Etherealplane = 21,
    Avernus = 22,
};

/** Convert database string to Sector enum */
inline std::optional<Sector> sector_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Sector> lookup = {
        {"STRUCTURE", Sector::Structure},
        {"CITY", Sector::City},
        {"FIELD", Sector::Field},
        {"FOREST", Sector::Forest},
        {"HILLS", Sector::Hills},
        {"MOUNTAIN", Sector::Mountain},
        {"SHALLOWS", Sector::Shallows},
        {"WATER", Sector::Water},
        {"UNDERWATER", Sector::Underwater},
        {"AIR", Sector::Air},
        {"ROAD", Sector::Road},
        {"GRASSLANDS", Sector::Grasslands},
        {"CAVE", Sector::Cave},
        {"RUINS", Sector::Ruins},
        {"SWAMP", Sector::Swamp},
        {"BEACH", Sector::Beach},
        {"UNDERDARK", Sector::Underdark},
        {"ASTRALPLANE", Sector::Astralplane},
        {"AIRPLANE", Sector::Airplane},
        {"FIREPLANE", Sector::Fireplane},
        {"EARTHPLANE", Sector::Earthplane},
        {"ETHEREALPLANE", Sector::Etherealplane},
        {"AVERNUS", Sector::Avernus},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Sector enum to database string */
inline std::string_view sector_to_db(Sector e) {
    switch (e) {
    case Sector::Structure:
        return "STRUCTURE";
    case Sector::City:
        return "CITY";
    case Sector::Field:
        return "FIELD";
    case Sector::Forest:
        return "FOREST";
    case Sector::Hills:
        return "HILLS";
    case Sector::Mountain:
        return "MOUNTAIN";
    case Sector::Shallows:
        return "SHALLOWS";
    case Sector::Water:
        return "WATER";
    case Sector::Underwater:
        return "UNDERWATER";
    case Sector::Air:
        return "AIR";
    case Sector::Road:
        return "ROAD";
    case Sector::Grasslands:
        return "GRASSLANDS";
    case Sector::Cave:
        return "CAVE";
    case Sector::Ruins:
        return "RUINS";
    case Sector::Swamp:
        return "SWAMP";
    case Sector::Beach:
        return "BEACH";
    case Sector::Underdark:
        return "UNDERDARK";
    case Sector::Astralplane:
        return "ASTRALPLANE";
    case Sector::Airplane:
        return "AIRPLANE";
    case Sector::Fireplane:
        return "FIREPLANE";
    case Sector::Earthplane:
        return "EARTHPLANE";
    case Sector::Etherealplane:
        return "ETHEREALPLANE";
    case Sector::Avernus:
        return "AVERNUS";
    }
    return "";
}

enum class Direction {
    North = 0,
    East = 1,
    South = 2,
    West = 3,
    Up = 4,
    Down = 5,
    Northeast = 6,
    Northwest = 7,
    Southeast = 8,
    Southwest = 9,
    In = 10,
    Out = 11,
    Portal = 12,
    None = 13,
};

/** Convert database string to Direction enum */
inline std::optional<Direction> direction_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Direction> lookup = {
        {"NORTH", Direction::North},
        {"EAST", Direction::East},
        {"SOUTH", Direction::South},
        {"WEST", Direction::West},
        {"UP", Direction::Up},
        {"DOWN", Direction::Down},
        {"NORTHEAST", Direction::Northeast},
        {"NORTHWEST", Direction::Northwest},
        {"SOUTHEAST", Direction::Southeast},
        {"SOUTHWEST", Direction::Southwest},
        {"IN", Direction::In},
        {"OUT", Direction::Out},
        {"PORTAL", Direction::Portal},
        {"NONE", Direction::None},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Direction enum to database string */
inline std::string_view direction_to_db(Direction e) {
    switch (e) {
    case Direction::North:
        return "NORTH";
    case Direction::East:
        return "EAST";
    case Direction::South:
        return "SOUTH";
    case Direction::West:
        return "WEST";
    case Direction::Up:
        return "UP";
    case Direction::Down:
        return "DOWN";
    case Direction::Northeast:
        return "NORTHEAST";
    case Direction::Northwest:
        return "NORTHWEST";
    case Direction::Southeast:
        return "SOUTHEAST";
    case Direction::Southwest:
        return "SOUTHWEST";
    case Direction::In:
        return "IN";
    case Direction::Out:
        return "OUT";
    case Direction::Portal:
        return "PORTAL";
    case Direction::None:
        return "NONE";
    }
    return "";
}

enum class ExitFlag {
    IsDoor = 0,
    Pickproof = 1,
    Hidden = 2,
    Bashable = 3,
    Magicproof = 4,
};

/** Convert database string to ExitFlag enum */
inline std::optional<ExitFlag> exit_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ExitFlag> lookup = {
        {"IS_DOOR", ExitFlag::IsDoor},    {"PICKPROOF", ExitFlag::Pickproof},   {"HIDDEN", ExitFlag::Hidden},
        {"BASHABLE", ExitFlag::Bashable}, {"MAGICPROOF", ExitFlag::Magicproof},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ExitFlag enum to database string */
inline std::string_view exit_flag_to_db(ExitFlag e) {
    switch (e) {
    case ExitFlag::IsDoor:
        return "IS_DOOR";
    case ExitFlag::Pickproof:
        return "PICKPROOF";
    case ExitFlag::Hidden:
        return "HIDDEN";
    case ExitFlag::Bashable:
        return "BASHABLE";
    case ExitFlag::Magicproof:
        return "MAGICPROOF";
    }
    return "";
}

enum class ExitState {
    Open = 0,
    Closed = 1,
    Locked = 2,
};

/** Convert database string to ExitState enum */
inline std::optional<ExitState> exit_state_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ExitState> lookup = {
        {"OPEN", ExitState::Open},
        {"CLOSED", ExitState::Closed},
        {"LOCKED", ExitState::Locked},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ExitState enum to database string */
inline std::string_view exit_state_to_db(ExitState e) {
    switch (e) {
    case ExitState::Open:
        return "OPEN";
    case ExitState::Closed:
        return "CLOSED";
    case ExitState::Locked:
        return "LOCKED";
    }
    return "";
}

enum class MagicAffinity {
    Fire = 0,
    Water = 1,
    Cold = 2,
    Earth = 3,
    Air = 4,
    Holy = 5,
    Unholy = 6,
    Shadow = 7,
    Death = 8,
    Astral = 9,
    Nature = 10,
    Arcane = 11,
    Chaos = 12,
};

/** Convert database string to MagicAffinity enum */
inline std::optional<MagicAffinity> magic_affinity_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MagicAffinity> lookup = {
        {"FIRE", MagicAffinity::Fire},     {"WATER", MagicAffinity::Water},   {"COLD", MagicAffinity::Cold},
        {"EARTH", MagicAffinity::Earth},   {"AIR", MagicAffinity::Air},       {"HOLY", MagicAffinity::Holy},
        {"UNHOLY", MagicAffinity::Unholy}, {"SHADOW", MagicAffinity::Shadow}, {"DEATH", MagicAffinity::Death},
        {"ASTRAL", MagicAffinity::Astral}, {"NATURE", MagicAffinity::Nature}, {"ARCANE", MagicAffinity::Arcane},
        {"CHAOS", MagicAffinity::Chaos},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MagicAffinity enum to database string */
inline std::string_view magic_affinity_to_db(MagicAffinity e) {
    switch (e) {
    case MagicAffinity::Fire:
        return "FIRE";
    case MagicAffinity::Water:
        return "WATER";
    case MagicAffinity::Cold:
        return "COLD";
    case MagicAffinity::Earth:
        return "EARTH";
    case MagicAffinity::Air:
        return "AIR";
    case MagicAffinity::Holy:
        return "HOLY";
    case MagicAffinity::Unholy:
        return "UNHOLY";
    case MagicAffinity::Shadow:
        return "SHADOW";
    case MagicAffinity::Death:
        return "DEATH";
    case MagicAffinity::Astral:
        return "ASTRAL";
    case MagicAffinity::Nature:
        return "NATURE";
    case MagicAffinity::Arcane:
        return "ARCANE";
    case MagicAffinity::Chaos:
        return "CHAOS";
    }
    return "";
}

// ============================================================================
// Mob System
// ============================================================================

enum class MobRole {
    Trash = 0,
    Normal = 1,
    Elite = 2,
    Miniboss = 3,
    Boss = 4,
    RaidBoss = 5,
};

/** Convert database string to MobRole enum */
inline std::optional<MobRole> mob_role_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobRole> lookup = {
        {"TRASH", MobRole::Trash},       {"NORMAL", MobRole::Normal}, {"ELITE", MobRole::Elite},
        {"MINIBOSS", MobRole::Miniboss}, {"BOSS", MobRole::Boss},     {"RAID_BOSS", MobRole::RaidBoss},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobRole enum to database string */
inline std::string_view mob_role_to_db(MobRole e) {
    switch (e) {
    case MobRole::Trash:
        return "TRASH";
    case MobRole::Normal:
        return "NORMAL";
    case MobRole::Elite:
        return "ELITE";
    case MobRole::Miniboss:
        return "MINIBOSS";
    case MobRole::Boss:
        return "BOSS";
    case MobRole::RaidBoss:
        return "RAID_BOSS";
    }
    return "";
}

enum class MobTrait {
    Illusion = 0,
    Animated = 1,
    PlayerPhantasm = 2,
    Aquatic = 3,
    Mount = 4,
    Summoned = 5,
    Pet = 6,
};

/** Convert database string to MobTrait enum */
inline std::optional<MobTrait> mob_trait_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobTrait> lookup = {
        {"ILLUSION", MobTrait::Illusion},
        {"ANIMATED", MobTrait::Animated},
        {"PLAYER_PHANTASM", MobTrait::PlayerPhantasm},
        {"AQUATIC", MobTrait::Aquatic},
        {"MOUNT", MobTrait::Mount},
        {"SUMMONED", MobTrait::Summoned},
        {"PET", MobTrait::Pet},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobTrait enum to database string */
inline std::string_view mob_trait_to_db(MobTrait e) {
    switch (e) {
    case MobTrait::Illusion:
        return "ILLUSION";
    case MobTrait::Animated:
        return "ANIMATED";
    case MobTrait::PlayerPhantasm:
        return "PLAYER_PHANTASM";
    case MobTrait::Aquatic:
        return "AQUATIC";
    case MobTrait::Mount:
        return "MOUNT";
    case MobTrait::Summoned:
        return "SUMMONED";
    case MobTrait::Pet:
        return "PET";
    }
    return "";
}

enum class MobBehavior {
    Sentinel = 0,
    StayZone = 1,
    Scavenger = 2,
    Track = 3,
    SlowTrack = 4,
    FastTrack = 5,
    Wimpy = 6,
    Aware = 7,
    Helper = 8,
    Protector = 9,
    Peacekeeper = 10,
    NoBash = 11,
    NoSummon = 12,
    NoVicious = 13,
    Memory = 14,
    Teacher = 15,
    Meditate = 16,
    NoScript = 17,
    NoClassAi = 18,
    Peaceful = 19,
    NoKill = 20,
};

/** Convert database string to MobBehavior enum */
inline std::optional<MobBehavior> mob_behavior_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobBehavior> lookup = {
        {"SENTINEL", MobBehavior::Sentinel},
        {"STAY_ZONE", MobBehavior::StayZone},
        {"SCAVENGER", MobBehavior::Scavenger},
        {"TRACK", MobBehavior::Track},
        {"SLOW_TRACK", MobBehavior::SlowTrack},
        {"FAST_TRACK", MobBehavior::FastTrack},
        {"WIMPY", MobBehavior::Wimpy},
        {"AWARE", MobBehavior::Aware},
        {"HELPER", MobBehavior::Helper},
        {"PROTECTOR", MobBehavior::Protector},
        {"PEACEKEEPER", MobBehavior::Peacekeeper},
        {"NO_BASH", MobBehavior::NoBash},
        {"NO_SUMMON", MobBehavior::NoSummon},
        {"NO_VICIOUS", MobBehavior::NoVicious},
        {"MEMORY", MobBehavior::Memory},
        {"TEACHER", MobBehavior::Teacher},
        {"MEDITATE", MobBehavior::Meditate},
        {"NO_SCRIPT", MobBehavior::NoScript},
        {"NO_CLASS_AI", MobBehavior::NoClassAi},
        {"PEACEFUL", MobBehavior::Peaceful},
        {"NO_KILL", MobBehavior::NoKill},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobBehavior enum to database string */
inline std::string_view mob_behavior_to_db(MobBehavior e) {
    switch (e) {
    case MobBehavior::Sentinel:
        return "SENTINEL";
    case MobBehavior::StayZone:
        return "STAY_ZONE";
    case MobBehavior::Scavenger:
        return "SCAVENGER";
    case MobBehavior::Track:
        return "TRACK";
    case MobBehavior::SlowTrack:
        return "SLOW_TRACK";
    case MobBehavior::FastTrack:
        return "FAST_TRACK";
    case MobBehavior::Wimpy:
        return "WIMPY";
    case MobBehavior::Aware:
        return "AWARE";
    case MobBehavior::Helper:
        return "HELPER";
    case MobBehavior::Protector:
        return "PROTECTOR";
    case MobBehavior::Peacekeeper:
        return "PEACEKEEPER";
    case MobBehavior::NoBash:
        return "NO_BASH";
    case MobBehavior::NoSummon:
        return "NO_SUMMON";
    case MobBehavior::NoVicious:
        return "NO_VICIOUS";
    case MobBehavior::Memory:
        return "MEMORY";
    case MobBehavior::Teacher:
        return "TEACHER";
    case MobBehavior::Meditate:
        return "MEDITATE";
    case MobBehavior::NoScript:
        return "NO_SCRIPT";
    case MobBehavior::NoClassAi:
        return "NO_CLASS_AI";
    case MobBehavior::Peaceful:
        return "PEACEFUL";
    case MobBehavior::NoKill:
        return "NO_KILL";
    }
    return "";
}

enum class Position {
    Dead = 0,
    Ghost = 1,
    MortallyWounded = 2,
    Incapacitated = 3,
    Stunned = 4,
    Sleeping = 5,
    Resting = 6,
    Sitting = 7,
    Standing = 8,
};

/** Convert database string to Position enum */
inline std::optional<Position> position_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Position> lookup = {
        {"DEAD", Position::Dead},
        {"GHOST", Position::Ghost},
        {"MORTALLY_WOUNDED", Position::MortallyWounded},
        {"INCAPACITATED", Position::Incapacitated},
        {"STUNNED", Position::Stunned},
        {"SLEEPING", Position::Sleeping},
        {"RESTING", Position::Resting},
        {"SITTING", Position::Sitting},
        {"STANDING", Position::Standing},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Position enum to database string */
inline std::string_view position_to_db(Position e) {
    switch (e) {
    case Position::Dead:
        return "DEAD";
    case Position::Ghost:
        return "GHOST";
    case Position::MortallyWounded:
        return "MORTALLY_WOUNDED";
    case Position::Incapacitated:
        return "INCAPACITATED";
    case Position::Stunned:
        return "STUNNED";
    case Position::Sleeping:
        return "SLEEPING";
    case Position::Resting:
        return "RESTING";
    case Position::Sitting:
        return "SITTING";
    case Position::Standing:
        return "STANDING";
    }
    return "";
}

enum class Stance {
    Dead = 0,
    Mort = 1,
    Incapacitated = 2,
    Stunned = 3,
    Sleeping = 4,
    Resting = 5,
    Alert = 6,
    Fighting = 7,
};

/** Convert database string to Stance enum */
inline std::optional<Stance> stance_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Stance> lookup = {
        {"DEAD", Stance::Dead},       {"MORT", Stance::Mort},         {"INCAPACITATED", Stance::Incapacitated},
        {"STUNNED", Stance::Stunned}, {"SLEEPING", Stance::Sleeping}, {"RESTING", Stance::Resting},
        {"ALERT", Stance::Alert},     {"FIGHTING", Stance::Fighting},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Stance enum to database string */
inline std::string_view stance_to_db(Stance e) {
    switch (e) {
    case Stance::Dead:
        return "DEAD";
    case Stance::Mort:
        return "MORT";
    case Stance::Incapacitated:
        return "INCAPACITATED";
    case Stance::Stunned:
        return "STUNNED";
    case Stance::Sleeping:
        return "SLEEPING";
    case Stance::Resting:
        return "RESTING";
    case Stance::Alert:
        return "ALERT";
    case Stance::Fighting:
        return "FIGHTING";
    }
    return "";
}

enum class Gender {
    Neutral = 0,
    Male = 1,
    Female = 2,
    NonBinary = 3,
};

/** Convert database string to Gender enum */
inline std::optional<Gender> gender_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Gender> lookup = {
        {"NEUTRAL", Gender::Neutral},
        {"MALE", Gender::Male},
        {"FEMALE", Gender::Female},
        {"NON_BINARY", Gender::NonBinary},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Gender enum to database string */
inline std::string_view gender_to_db(Gender e) {
    switch (e) {
    case Gender::Neutral:
        return "NEUTRAL";
    case Gender::Male:
        return "MALE";
    case Gender::Female:
        return "FEMALE";
    case Gender::NonBinary:
        return "NON_BINARY";
    }
    return "";
}

enum class Size {
    Tiny = 0,
    Small = 1,
    Medium = 2,
    Large = 3,
    Huge = 4,
    Giant = 5,
    Gargantuan = 6,
    Colossal = 7,
    Titanic = 8,
    Mountainous = 9,
};

/** Convert database string to Size enum */
inline std::optional<Size> size_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Size> lookup = {
        {"TINY", Size::Tiny},
        {"SMALL", Size::Small},
        {"MEDIUM", Size::Medium},
        {"LARGE", Size::Large},
        {"HUGE", Size::Huge},
        {"GIANT", Size::Giant},
        {"GARGANTUAN", Size::Gargantuan},
        {"COLOSSAL", Size::Colossal},
        {"TITANIC", Size::Titanic},
        {"MOUNTAINOUS", Size::Mountainous},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Size enum to database string */
inline std::string_view size_to_db(Size e) {
    switch (e) {
    case Size::Tiny:
        return "TINY";
    case Size::Small:
        return "SMALL";
    case Size::Medium:
        return "MEDIUM";
    case Size::Large:
        return "LARGE";
    case Size::Huge:
        return "HUGE";
    case Size::Giant:
        return "GIANT";
    case Size::Gargantuan:
        return "GARGANTUAN";
    case Size::Colossal:
        return "COLOSSAL";
    case Size::Titanic:
        return "TITANIC";
    case Size::Mountainous:
        return "MOUNTAINOUS";
    }
    return "";
}

enum class LifeForce {
    Life = 0,
    Undead = 1,
    Magic = 2,
    Celestial = 3,
    Demonic = 4,
    Elemental = 5,
};

/** Convert database string to LifeForce enum */
inline std::optional<LifeForce> life_force_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, LifeForce> lookup = {
        {"LIFE", LifeForce::Life},           {"UNDEAD", LifeForce::Undead},   {"MAGIC", LifeForce::Magic},
        {"CELESTIAL", LifeForce::Celestial}, {"DEMONIC", LifeForce::Demonic}, {"ELEMENTAL", LifeForce::Elemental},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert LifeForce enum to database string */
inline std::string_view life_force_to_db(LifeForce e) {
    switch (e) {
    case LifeForce::Life:
        return "LIFE";
    case LifeForce::Undead:
        return "UNDEAD";
    case LifeForce::Magic:
        return "MAGIC";
    case LifeForce::Celestial:
        return "CELESTIAL";
    case LifeForce::Demonic:
        return "DEMONIC";
    case LifeForce::Elemental:
        return "ELEMENTAL";
    }
    return "";
}

enum class Composition {
    Flesh = 0,
    Earth = 1,
    Air = 2,
    Fire = 3,
    Water = 4,
    Ice = 5,
    Mist = 6,
    Ether = 7,
    Metal = 8,
    Stone = 9,
    Bone = 10,
    Lava = 11,
    Plant = 12,
};

/** Convert database string to Composition enum */
inline std::optional<Composition> composition_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Composition> lookup = {
        {"FLESH", Composition::Flesh}, {"EARTH", Composition::Earth}, {"AIR", Composition::Air},
        {"FIRE", Composition::Fire},   {"WATER", Composition::Water}, {"ICE", Composition::Ice},
        {"MIST", Composition::Mist},   {"ETHER", Composition::Ether}, {"METAL", Composition::Metal},
        {"STONE", Composition::Stone}, {"BONE", Composition::Bone},   {"LAVA", Composition::Lava},
        {"PLANT", Composition::Plant},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Composition enum to database string */
inline std::string_view composition_to_db(Composition e) {
    switch (e) {
    case Composition::Flesh:
        return "FLESH";
    case Composition::Earth:
        return "EARTH";
    case Composition::Air:
        return "AIR";
    case Composition::Fire:
        return "FIRE";
    case Composition::Water:
        return "WATER";
    case Composition::Ice:
        return "ICE";
    case Composition::Mist:
        return "MIST";
    case Composition::Ether:
        return "ETHER";
    case Composition::Metal:
        return "METAL";
    case Composition::Stone:
        return "STONE";
    case Composition::Bone:
        return "BONE";
    case Composition::Lava:
        return "LAVA";
    case Composition::Plant:
        return "PLANT";
    }
    return "";
}

enum class DamageType {
    Hit = 0,
    Sting = 1,
    Whip = 2,
    Slash = 3,
    Bite = 4,
    Bludgeon = 5,
    Crush = 6,
    Pound = 7,
    Claw = 8,
    Maul = 9,
    Thrash = 10,
    Pierce = 11,
    Blast = 12,
    Punch = 13,
    Stab = 14,
    Fire = 15,
    Cold = 16,
    Acid = 17,
    Shock = 18,
    Poison = 19,
    Align = 20,
    Mental = 21,
    Rot = 22,
    Energy = 23,
    Water = 24,
};

/** Convert database string to DamageType enum */
inline std::optional<DamageType> damage_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, DamageType> lookup = {
        {"HIT", DamageType::Hit},       {"STING", DamageType::Sting},   {"WHIP", DamageType::Whip},
        {"SLASH", DamageType::Slash},   {"BITE", DamageType::Bite},     {"BLUDGEON", DamageType::Bludgeon},
        {"CRUSH", DamageType::Crush},   {"POUND", DamageType::Pound},   {"CLAW", DamageType::Claw},
        {"MAUL", DamageType::Maul},     {"THRASH", DamageType::Thrash}, {"PIERCE", DamageType::Pierce},
        {"BLAST", DamageType::Blast},   {"PUNCH", DamageType::Punch},   {"STAB", DamageType::Stab},
        {"FIRE", DamageType::Fire},     {"COLD", DamageType::Cold},     {"ACID", DamageType::Acid},
        {"SHOCK", DamageType::Shock},   {"POISON", DamageType::Poison}, {"ALIGN", DamageType::Align},
        {"MENTAL", DamageType::Mental}, {"ROT", DamageType::Rot},       {"ENERGY", DamageType::Energy},
        {"WATER", DamageType::Water},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert DamageType enum to database string */
inline std::string_view damage_type_to_db(DamageType e) {
    switch (e) {
    case DamageType::Hit:
        return "HIT";
    case DamageType::Sting:
        return "STING";
    case DamageType::Whip:
        return "WHIP";
    case DamageType::Slash:
        return "SLASH";
    case DamageType::Bite:
        return "BITE";
    case DamageType::Bludgeon:
        return "BLUDGEON";
    case DamageType::Crush:
        return "CRUSH";
    case DamageType::Pound:
        return "POUND";
    case DamageType::Claw:
        return "CLAW";
    case DamageType::Maul:
        return "MAUL";
    case DamageType::Thrash:
        return "THRASH";
    case DamageType::Pierce:
        return "PIERCE";
    case DamageType::Blast:
        return "BLAST";
    case DamageType::Punch:
        return "PUNCH";
    case DamageType::Stab:
        return "STAB";
    case DamageType::Fire:
        return "FIRE";
    case DamageType::Cold:
        return "COLD";
    case DamageType::Acid:
        return "ACID";
    case DamageType::Shock:
        return "SHOCK";
    case DamageType::Poison:
        return "POISON";
    case DamageType::Align:
        return "ALIGN";
    case DamageType::Mental:
        return "MENTAL";
    case DamageType::Rot:
        return "ROT";
    case DamageType::Energy:
        return "ENERGY";
    case DamageType::Water:
        return "WATER";
    }
    return "";
}

// ============================================================================
// Object System
// ============================================================================

enum class ObjectType {
    Nothing = 0,
    Light = 1,
    Scroll = 2,
    Wand = 3,
    Staff = 4,
    Weapon = 5,
    Fireweapon = 6,
    Missile = 7,
    Treasure = 8,
    Armor = 9,
    Potion = 10,
    Worn = 11,
    Other = 12,
    Trash = 13,
    Trap = 14,
    Container = 15,
    Note = 16,
    Drinkcontainer = 17,
    Key = 18,
    Food = 19,
    Money = 20,
    Pen = 21,
    Boat = 22,
    Fountain = 23,
    Portal = 24,
    Rope = 25,
    Spellbook = 26,
    Wall = 27,
    Touchstone = 28,
    Board = 29,
    Instrument = 30,
    Vehicle = 31,
    Corpse = 32,
    Kit = 33,
    Wings = 34,
    Perfume = 35,
    Disguise = 36,
    Poison = 37,
};

/** Convert database string to ObjectType enum */
inline std::optional<ObjectType> object_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ObjectType> lookup = {
        {"NOTHING", ObjectType::Nothing},
        {"LIGHT", ObjectType::Light},
        {"SCROLL", ObjectType::Scroll},
        {"WAND", ObjectType::Wand},
        {"STAFF", ObjectType::Staff},
        {"WEAPON", ObjectType::Weapon},
        {"FIREWEAPON", ObjectType::Fireweapon},
        {"MISSILE", ObjectType::Missile},
        {"TREASURE", ObjectType::Treasure},
        {"ARMOR", ObjectType::Armor},
        {"POTION", ObjectType::Potion},
        {"WORN", ObjectType::Worn},
        {"OTHER", ObjectType::Other},
        {"TRASH", ObjectType::Trash},
        {"TRAP", ObjectType::Trap},
        {"CONTAINER", ObjectType::Container},
        {"NOTE", ObjectType::Note},
        {"DRINKCONTAINER", ObjectType::Drinkcontainer},
        {"KEY", ObjectType::Key},
        {"FOOD", ObjectType::Food},
        {"MONEY", ObjectType::Money},
        {"PEN", ObjectType::Pen},
        {"BOAT", ObjectType::Boat},
        {"FOUNTAIN", ObjectType::Fountain},
        {"PORTAL", ObjectType::Portal},
        {"ROPE", ObjectType::Rope},
        {"SPELLBOOK", ObjectType::Spellbook},
        {"WALL", ObjectType::Wall},
        {"TOUCHSTONE", ObjectType::Touchstone},
        {"BOARD", ObjectType::Board},
        {"INSTRUMENT", ObjectType::Instrument},
        {"VEHICLE", ObjectType::Vehicle},
        {"CORPSE", ObjectType::Corpse},
        {"KIT", ObjectType::Kit},
        {"WINGS", ObjectType::Wings},
        {"PERFUME", ObjectType::Perfume},
        {"DISGUISE", ObjectType::Disguise},
        {"POISON", ObjectType::Poison},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ObjectType enum to database string */
inline std::string_view object_type_to_db(ObjectType e) {
    switch (e) {
    case ObjectType::Nothing:
        return "NOTHING";
    case ObjectType::Light:
        return "LIGHT";
    case ObjectType::Scroll:
        return "SCROLL";
    case ObjectType::Wand:
        return "WAND";
    case ObjectType::Staff:
        return "STAFF";
    case ObjectType::Weapon:
        return "WEAPON";
    case ObjectType::Fireweapon:
        return "FIREWEAPON";
    case ObjectType::Missile:
        return "MISSILE";
    case ObjectType::Treasure:
        return "TREASURE";
    case ObjectType::Armor:
        return "ARMOR";
    case ObjectType::Potion:
        return "POTION";
    case ObjectType::Worn:
        return "WORN";
    case ObjectType::Other:
        return "OTHER";
    case ObjectType::Trash:
        return "TRASH";
    case ObjectType::Trap:
        return "TRAP";
    case ObjectType::Container:
        return "CONTAINER";
    case ObjectType::Note:
        return "NOTE";
    case ObjectType::Drinkcontainer:
        return "DRINKCONTAINER";
    case ObjectType::Key:
        return "KEY";
    case ObjectType::Food:
        return "FOOD";
    case ObjectType::Money:
        return "MONEY";
    case ObjectType::Pen:
        return "PEN";
    case ObjectType::Boat:
        return "BOAT";
    case ObjectType::Fountain:
        return "FOUNTAIN";
    case ObjectType::Portal:
        return "PORTAL";
    case ObjectType::Rope:
        return "ROPE";
    case ObjectType::Spellbook:
        return "SPELLBOOK";
    case ObjectType::Wall:
        return "WALL";
    case ObjectType::Touchstone:
        return "TOUCHSTONE";
    case ObjectType::Board:
        return "BOARD";
    case ObjectType::Instrument:
        return "INSTRUMENT";
    case ObjectType::Vehicle:
        return "VEHICLE";
    case ObjectType::Corpse:
        return "CORPSE";
    case ObjectType::Kit:
        return "KIT";
    case ObjectType::Wings:
        return "WINGS";
    case ObjectType::Perfume:
        return "PERFUME";
    case ObjectType::Disguise:
        return "DISGUISE";
    case ObjectType::Poison:
        return "POISON";
    }
    return "";
}

enum class ObjectFlag {
    Glow = 0,
    Hum = 1,
    Invisible = 2,
    Magic = 3,
    Permanent = 4,
    Temporary = 5,
    Decomposing = 6,
    Float = 7,
    Buoyant = 8,
    Vehicle = 9,
    Soulbound = 10,
};

/** Convert database string to ObjectFlag enum */
inline std::optional<ObjectFlag> object_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ObjectFlag> lookup = {
        {"GLOW", ObjectFlag::Glow},
        {"HUM", ObjectFlag::Hum},
        {"INVISIBLE", ObjectFlag::Invisible},
        {"MAGIC", ObjectFlag::Magic},
        {"PERMANENT", ObjectFlag::Permanent},
        {"TEMPORARY", ObjectFlag::Temporary},
        {"DECOMPOSING", ObjectFlag::Decomposing},
        {"FLOAT", ObjectFlag::Float},
        {"BUOYANT", ObjectFlag::Buoyant},
        {"VEHICLE", ObjectFlag::Vehicle},
        {"SOULBOUND", ObjectFlag::Soulbound},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ObjectFlag enum to database string */
inline std::string_view object_flag_to_db(ObjectFlag e) {
    switch (e) {
    case ObjectFlag::Glow:
        return "GLOW";
    case ObjectFlag::Hum:
        return "HUM";
    case ObjectFlag::Invisible:
        return "INVISIBLE";
    case ObjectFlag::Magic:
        return "MAGIC";
    case ObjectFlag::Permanent:
        return "PERMANENT";
    case ObjectFlag::Temporary:
        return "TEMPORARY";
    case ObjectFlag::Decomposing:
        return "DECOMPOSING";
    case ObjectFlag::Float:
        return "FLOAT";
    case ObjectFlag::Buoyant:
        return "BUOYANT";
    case ObjectFlag::Vehicle:
        return "VEHICLE";
    case ObjectFlag::Soulbound:
        return "SOULBOUND";
    }
    return "";
}

enum class WearFlag {
    Finger = 0,
    Neck = 1,
    Ear = 2,
    Wrist = 3,
    Head = 4,
    Eyes = 5,
    Face = 6,
    Body = 7,
    About = 8,
    Arms = 9,
    Hands = 10,
    Waist = 11,
    Belt = 12,
    Legs = 13,
    Feet = 14,
    Tail = 15,
    Mainhand = 16,
    Offhand = 17,
    Twohand = 18,
    Badge = 19,
    Hover = 20,
    Disguise = 21,
};

/** Convert database string to WearFlag enum */
inline std::optional<WearFlag> wear_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, WearFlag> lookup = {
        {"FINGER", WearFlag::Finger},     {"NECK", WearFlag::Neck},         {"EAR", WearFlag::Ear},
        {"WRIST", WearFlag::Wrist},       {"HEAD", WearFlag::Head},         {"EYES", WearFlag::Eyes},
        {"FACE", WearFlag::Face},         {"BODY", WearFlag::Body},         {"ABOUT", WearFlag::About},
        {"ARMS", WearFlag::Arms},         {"HANDS", WearFlag::Hands},       {"WAIST", WearFlag::Waist},
        {"BELT", WearFlag::Belt},         {"LEGS", WearFlag::Legs},         {"FEET", WearFlag::Feet},
        {"TAIL", WearFlag::Tail},         {"MAINHAND", WearFlag::Mainhand}, {"OFFHAND", WearFlag::Offhand},
        {"TWOHAND", WearFlag::Twohand},   {"BADGE", WearFlag::Badge},       {"HOVER", WearFlag::Hover},
        {"DISGUISE", WearFlag::Disguise},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert WearFlag enum to database string */
inline std::string_view wear_flag_to_db(WearFlag e) {
    switch (e) {
    case WearFlag::Finger:
        return "FINGER";
    case WearFlag::Neck:
        return "NECK";
    case WearFlag::Ear:
        return "EAR";
    case WearFlag::Wrist:
        return "WRIST";
    case WearFlag::Head:
        return "HEAD";
    case WearFlag::Eyes:
        return "EYES";
    case WearFlag::Face:
        return "FACE";
    case WearFlag::Body:
        return "BODY";
    case WearFlag::About:
        return "ABOUT";
    case WearFlag::Arms:
        return "ARMS";
    case WearFlag::Hands:
        return "HANDS";
    case WearFlag::Waist:
        return "WAIST";
    case WearFlag::Belt:
        return "BELT";
    case WearFlag::Legs:
        return "LEGS";
    case WearFlag::Feet:
        return "FEET";
    case WearFlag::Tail:
        return "TAIL";
    case WearFlag::Mainhand:
        return "MAINHAND";
    case WearFlag::Offhand:
        return "OFFHAND";
    case WearFlag::Twohand:
        return "TWOHAND";
    case WearFlag::Badge:
        return "BADGE";
    case WearFlag::Hover:
        return "HOVER";
    case WearFlag::Disguise:
        return "DISGUISE";
    }
    return "";
}

enum class Alignment {
    Good = 0,
    Neutral = 1,
    Evil = 2,
};

/** Convert database string to Alignment enum */
inline std::optional<Alignment> alignment_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Alignment> lookup = {
        {"GOOD", Alignment::Good},
        {"NEUTRAL", Alignment::Neutral},
        {"EVIL", Alignment::Evil},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Alignment enum to database string */
inline std::string_view alignment_to_db(Alignment e) {
    switch (e) {
    case Alignment::Good:
        return "GOOD";
    case Alignment::Neutral:
        return "NEUTRAL";
    case Alignment::Evil:
        return "EVIL";
    }
    return "";
}

// ============================================================================
// Effect System
// ============================================================================

enum class ElementType {
    Physical = 0,
    Slash = 1,
    Pierce = 2,
    Crush = 3,
    Force = 4,
    Sonic = 5,
    Bleed = 6,
    Fire = 7,
    Cold = 8,
    Water = 9,
    Earth = 10,
    Air = 11,
    Shock = 12,
    Acid = 13,
    Poison = 14,
    Radiant = 15,
    Shadow = 16,
    Holy = 17,
    Unholy = 18,
    Heal = 19,
    Necrotic = 20,
    Mental = 21,
    Nature = 22,
};

/** Convert database string to ElementType enum */
inline std::optional<ElementType> element_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ElementType> lookup = {
        {"PHYSICAL", ElementType::Physical}, {"SLASH", ElementType::Slash},   {"PIERCE", ElementType::Pierce},
        {"CRUSH", ElementType::Crush},       {"FORCE", ElementType::Force},   {"SONIC", ElementType::Sonic},
        {"BLEED", ElementType::Bleed},       {"FIRE", ElementType::Fire},     {"COLD", ElementType::Cold},
        {"WATER", ElementType::Water},       {"EARTH", ElementType::Earth},   {"AIR", ElementType::Air},
        {"SHOCK", ElementType::Shock},       {"ACID", ElementType::Acid},     {"POISON", ElementType::Poison},
        {"RADIANT", ElementType::Radiant},   {"SHADOW", ElementType::Shadow}, {"HOLY", ElementType::Holy},
        {"UNHOLY", ElementType::Unholy},     {"HEAL", ElementType::Heal},     {"NECROTIC", ElementType::Necrotic},
        {"MENTAL", ElementType::Mental},     {"NATURE", ElementType::Nature},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ElementType enum to database string */
inline std::string_view element_type_to_db(ElementType e) {
    switch (e) {
    case ElementType::Physical:
        return "PHYSICAL";
    case ElementType::Slash:
        return "SLASH";
    case ElementType::Pierce:
        return "PIERCE";
    case ElementType::Crush:
        return "CRUSH";
    case ElementType::Force:
        return "FORCE";
    case ElementType::Sonic:
        return "SONIC";
    case ElementType::Bleed:
        return "BLEED";
    case ElementType::Fire:
        return "FIRE";
    case ElementType::Cold:
        return "COLD";
    case ElementType::Water:
        return "WATER";
    case ElementType::Earth:
        return "EARTH";
    case ElementType::Air:
        return "AIR";
    case ElementType::Shock:
        return "SHOCK";
    case ElementType::Acid:
        return "ACID";
    case ElementType::Poison:
        return "POISON";
    case ElementType::Radiant:
        return "RADIANT";
    case ElementType::Shadow:
        return "SHADOW";
    case ElementType::Holy:
        return "HOLY";
    case ElementType::Unholy:
        return "UNHOLY";
    case ElementType::Heal:
        return "HEAL";
    case ElementType::Necrotic:
        return "NECROTIC";
    case ElementType::Mental:
        return "MENTAL";
    case ElementType::Nature:
        return "NATURE";
    }
    return "";
}

enum class ApplyType {
    Ac = 0,
    Hitroll = 1,
    Damroll = 2,
    Str = 3,
    Dex = 4,
    Int = 5,
    Wis = 6,
    Con = 7,
    Cha = 8,
    SavingPara = 9,
    SavingRod = 10,
    SavingPetri = 11,
    SavingBreath = 12,
    SavingSpell = 13,
    HitRegen = 14,
    MaxHp = 15,
    MaxMana = 16,
    MaxMovement = 17,
    Perception = 18,
    Hiddenness = 19,
    Size = 20,
    Age = 21,
    CharWeight = 22,
    CharHeight = 23,
    Focus = 24,
    Composition = 25,
    Level = 26,
    None = 27,
};

/** Convert database string to ApplyType enum */
inline std::optional<ApplyType> apply_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ApplyType> lookup = {
        {"AC", ApplyType::Ac},
        {"HITROLL", ApplyType::Hitroll},
        {"DAMROLL", ApplyType::Damroll},
        {"STR", ApplyType::Str},
        {"DEX", ApplyType::Dex},
        {"INT", ApplyType::Int},
        {"WIS", ApplyType::Wis},
        {"CON", ApplyType::Con},
        {"CHA", ApplyType::Cha},
        {"SAVING_PARA", ApplyType::SavingPara},
        {"SAVING_ROD", ApplyType::SavingRod},
        {"SAVING_PETRI", ApplyType::SavingPetri},
        {"SAVING_BREATH", ApplyType::SavingBreath},
        {"SAVING_SPELL", ApplyType::SavingSpell},
        {"HIT_REGEN", ApplyType::HitRegen},
        {"MAX_HP", ApplyType::MaxHp},
        {"MAX_MANA", ApplyType::MaxMana},
        {"MAX_MOVEMENT", ApplyType::MaxMovement},
        {"PERCEPTION", ApplyType::Perception},
        {"HIDDENNESS", ApplyType::Hiddenness},
        {"SIZE", ApplyType::Size},
        {"AGE", ApplyType::Age},
        {"CHAR_WEIGHT", ApplyType::CharWeight},
        {"CHAR_HEIGHT", ApplyType::CharHeight},
        {"FOCUS", ApplyType::Focus},
        {"COMPOSITION", ApplyType::Composition},
        {"LEVEL", ApplyType::Level},
        {"NONE", ApplyType::None},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ApplyType enum to database string */
inline std::string_view apply_type_to_db(ApplyType e) {
    switch (e) {
    case ApplyType::Ac:
        return "AC";
    case ApplyType::Hitroll:
        return "HITROLL";
    case ApplyType::Damroll:
        return "DAMROLL";
    case ApplyType::Str:
        return "STR";
    case ApplyType::Dex:
        return "DEX";
    case ApplyType::Int:
        return "INT";
    case ApplyType::Wis:
        return "WIS";
    case ApplyType::Con:
        return "CON";
    case ApplyType::Cha:
        return "CHA";
    case ApplyType::SavingPara:
        return "SAVING_PARA";
    case ApplyType::SavingRod:
        return "SAVING_ROD";
    case ApplyType::SavingPetri:
        return "SAVING_PETRI";
    case ApplyType::SavingBreath:
        return "SAVING_BREATH";
    case ApplyType::SavingSpell:
        return "SAVING_SPELL";
    case ApplyType::HitRegen:
        return "HIT_REGEN";
    case ApplyType::MaxHp:
        return "MAX_HP";
    case ApplyType::MaxMana:
        return "MAX_MANA";
    case ApplyType::MaxMovement:
        return "MAX_MOVEMENT";
    case ApplyType::Perception:
        return "PERCEPTION";
    case ApplyType::Hiddenness:
        return "HIDDENNESS";
    case ApplyType::Size:
        return "SIZE";
    case ApplyType::Age:
        return "AGE";
    case ApplyType::CharWeight:
        return "CHAR_WEIGHT";
    case ApplyType::CharHeight:
        return "CHAR_HEIGHT";
    case ApplyType::Focus:
        return "FOCUS";
    case ApplyType::Composition:
        return "COMPOSITION";
    case ApplyType::Level:
        return "LEVEL";
    case ApplyType::None:
        return "NONE";
    }
    return "";
}

// ============================================================================
// Character System
// ============================================================================

enum class Race {
    Human = 0,
    Elf = 1,
    Gnome = 2,
    Dwarf = 3,
    Drow = 4,
    Duergar = 5,
    HalfElf = 6,
    Halfling = 7,
    Sverfneblin = 8,
    Goliath = 9,
    Brownie = 10,
    FaerieSeelie = 11,
    FaerieUnseelie = 12,
    Nymph = 13,
    Arborean = 14,
    Troll = 15,
    Ogre = 16,
    Orc = 17,
    Goblin = 18,
    Giant = 19,
    Demon = 20,
    DragonGeneral = 21,
    DragonFire = 22,
    DragonFrost = 23,
    DragonAcid = 24,
    DragonLightning = 25,
    DragonGas = 26,
    DragonbornFire = 27,
    DragonbornFrost = 28,
    DragonbornAcid = 29,
    DragonbornLightning = 30,
    DragonbornGas = 31,
    Humanoid = 32,
    Animal = 33,
    Plant = 34,
    Other = 35,
};

/** Convert database string to Race enum */
inline std::optional<Race> race_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Race> lookup = {
        {"HUMAN", Race::Human},
        {"ELF", Race::Elf},
        {"GNOME", Race::Gnome},
        {"DWARF", Race::Dwarf},
        {"DROW", Race::Drow},
        {"DUERGAR", Race::Duergar},
        {"HALF_ELF", Race::HalfElf},
        {"HALFLING", Race::Halfling},
        {"SVERFNEBLIN", Race::Sverfneblin},
        {"GOLIATH", Race::Goliath},
        {"BROWNIE", Race::Brownie},
        {"FAERIE_SEELIE", Race::FaerieSeelie},
        {"FAERIE_UNSEELIE", Race::FaerieUnseelie},
        {"NYMPH", Race::Nymph},
        {"ARBOREAN", Race::Arborean},
        {"TROLL", Race::Troll},
        {"OGRE", Race::Ogre},
        {"ORC", Race::Orc},
        {"GOBLIN", Race::Goblin},
        {"GIANT", Race::Giant},
        {"DEMON", Race::Demon},
        {"DRAGON_GENERAL", Race::DragonGeneral},
        {"DRAGON_FIRE", Race::DragonFire},
        {"DRAGON_FROST", Race::DragonFrost},
        {"DRAGON_ACID", Race::DragonAcid},
        {"DRAGON_LIGHTNING", Race::DragonLightning},
        {"DRAGON_GAS", Race::DragonGas},
        {"DRAGONBORN_FIRE", Race::DragonbornFire},
        {"DRAGONBORN_FROST", Race::DragonbornFrost},
        {"DRAGONBORN_ACID", Race::DragonbornAcid},
        {"DRAGONBORN_LIGHTNING", Race::DragonbornLightning},
        {"DRAGONBORN_GAS", Race::DragonbornGas},
        {"HUMANOID", Race::Humanoid},
        {"ANIMAL", Race::Animal},
        {"PLANT", Race::Plant},
        {"OTHER", Race::Other},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Race enum to database string */
inline std::string_view race_to_db(Race e) {
    switch (e) {
    case Race::Human:
        return "HUMAN";
    case Race::Elf:
        return "ELF";
    case Race::Gnome:
        return "GNOME";
    case Race::Dwarf:
        return "DWARF";
    case Race::Drow:
        return "DROW";
    case Race::Duergar:
        return "DUERGAR";
    case Race::HalfElf:
        return "HALF_ELF";
    case Race::Halfling:
        return "HALFLING";
    case Race::Sverfneblin:
        return "SVERFNEBLIN";
    case Race::Goliath:
        return "GOLIATH";
    case Race::Brownie:
        return "BROWNIE";
    case Race::FaerieSeelie:
        return "FAERIE_SEELIE";
    case Race::FaerieUnseelie:
        return "FAERIE_UNSEELIE";
    case Race::Nymph:
        return "NYMPH";
    case Race::Arborean:
        return "ARBOREAN";
    case Race::Troll:
        return "TROLL";
    case Race::Ogre:
        return "OGRE";
    case Race::Orc:
        return "ORC";
    case Race::Goblin:
        return "GOBLIN";
    case Race::Giant:
        return "GIANT";
    case Race::Demon:
        return "DEMON";
    case Race::DragonGeneral:
        return "DRAGON_GENERAL";
    case Race::DragonFire:
        return "DRAGON_FIRE";
    case Race::DragonFrost:
        return "DRAGON_FROST";
    case Race::DragonAcid:
        return "DRAGON_ACID";
    case Race::DragonLightning:
        return "DRAGON_LIGHTNING";
    case Race::DragonGas:
        return "DRAGON_GAS";
    case Race::DragonbornFire:
        return "DRAGONBORN_FIRE";
    case Race::DragonbornFrost:
        return "DRAGONBORN_FROST";
    case Race::DragonbornAcid:
        return "DRAGONBORN_ACID";
    case Race::DragonbornLightning:
        return "DRAGONBORN_LIGHTNING";
    case Race::DragonbornGas:
        return "DRAGONBORN_GAS";
    case Race::Humanoid:
        return "HUMANOID";
    case Race::Animal:
        return "ANIMAL";
    case Race::Plant:
        return "PLANT";
    case Race::Other:
        return "OTHER";
    }
    return "";
}

enum class RaceAlign {
    Unknown = 0,
    Good = 1,
    Evil = 2,
};

/** Convert database string to RaceAlign enum */
inline std::optional<RaceAlign> race_align_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, RaceAlign> lookup = {
        {"UNKNOWN", RaceAlign::Unknown},
        {"GOOD", RaceAlign::Good},
        {"EVIL", RaceAlign::Evil},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert RaceAlign enum to database string */
inline std::string_view race_align_to_db(RaceAlign e) {
    switch (e) {
    case RaceAlign::Unknown:
        return "UNKNOWN";
    case RaceAlign::Good:
        return "GOOD";
    case RaceAlign::Evil:
        return "EVIL";
    }
    return "";
}

enum class SkillCategory {
    Primary = 0,
    Secondary = 1,
    Restricted = 2,
    Forbidden = 3,
};

/** Convert database string to SkillCategory enum */
inline std::optional<SkillCategory> skill_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SkillCategory> lookup = {
        {"PRIMARY", SkillCategory::Primary},
        {"SECONDARY", SkillCategory::Secondary},
        {"RESTRICTED", SkillCategory::Restricted},
        {"FORBIDDEN", SkillCategory::Forbidden},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SkillCategory enum to database string */
inline std::string_view skill_category_to_db(SkillCategory e) {
    switch (e) {
    case SkillCategory::Primary:
        return "PRIMARY";
    case SkillCategory::Secondary:
        return "SECONDARY";
    case SkillCategory::Restricted:
        return "RESTRICTED";
    case SkillCategory::Forbidden:
        return "FORBIDDEN";
    }
    return "";
}

enum class SkillType {
    Weapon = 0,
    Combat = 1,
    Magic = 2,
    Stealth = 3,
    Social = 4,
    Crafting = 5,
    Survival = 6,
    Knowledge = 7,
    Utility = 8,
};

/** Convert database string to SkillType enum */
inline std::optional<SkillType> skill_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SkillType> lookup = {
        {"WEAPON", SkillType::Weapon},     {"COMBAT", SkillType::Combat},       {"MAGIC", SkillType::Magic},
        {"STEALTH", SkillType::Stealth},   {"SOCIAL", SkillType::Social},       {"CRAFTING", SkillType::Crafting},
        {"SURVIVAL", SkillType::Survival}, {"KNOWLEDGE", SkillType::Knowledge}, {"UTILITY", SkillType::Utility},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SkillType enum to database string */
inline std::string_view skill_type_to_db(SkillType e) {
    switch (e) {
    case SkillType::Weapon:
        return "WEAPON";
    case SkillType::Combat:
        return "COMBAT";
    case SkillType::Magic:
        return "MAGIC";
    case SkillType::Stealth:
        return "STEALTH";
    case SkillType::Social:
        return "SOCIAL";
    case SkillType::Crafting:
        return "CRAFTING";
    case SkillType::Survival:
        return "SURVIVAL";
    case SkillType::Knowledge:
        return "KNOWLEDGE";
    case SkillType::Utility:
        return "UTILITY";
    }
    return "";
}

// ============================================================================
// Ability System
// ============================================================================

enum class SpellSphere {
    Generic = 0,
    Fire = 1,
    Water = 2,
    Earth = 3,
    Air = 4,
    Healing = 5,
    Protection = 6,
    Enchantment = 7,
    Summoning = 8,
    Death = 9,
    Divination = 10,
};

/** Convert database string to SpellSphere enum */
inline std::optional<SpellSphere> spell_sphere_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SpellSphere> lookup = {
        {"GENERIC", SpellSphere::Generic},
        {"FIRE", SpellSphere::Fire},
        {"WATER", SpellSphere::Water},
        {"EARTH", SpellSphere::Earth},
        {"AIR", SpellSphere::Air},
        {"HEALING", SpellSphere::Healing},
        {"PROTECTION", SpellSphere::Protection},
        {"ENCHANTMENT", SpellSphere::Enchantment},
        {"SUMMONING", SpellSphere::Summoning},
        {"DEATH", SpellSphere::Death},
        {"DIVINATION", SpellSphere::Divination},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SpellSphere enum to database string */
inline std::string_view spell_sphere_to_db(SpellSphere e) {
    switch (e) {
    case SpellSphere::Generic:
        return "GENERIC";
    case SpellSphere::Fire:
        return "FIRE";
    case SpellSphere::Water:
        return "WATER";
    case SpellSphere::Earth:
        return "EARTH";
    case SpellSphere::Air:
        return "AIR";
    case SpellSphere::Healing:
        return "HEALING";
    case SpellSphere::Protection:
        return "PROTECTION";
    case SpellSphere::Enchantment:
        return "ENCHANTMENT";
    case SpellSphere::Summoning:
        return "SUMMONING";
    case SpellSphere::Death:
        return "DEATH";
    case SpellSphere::Divination:
        return "DIVINATION";
    }
    return "";
}

enum class TargetType {
    Self = 0,
    AllyPc = 1,
    AllyNpc = 2,
    AllyGroup = 3,
    EnemyPc = 4,
    EnemyNpc = 5,
    ObjectInv = 6,
    ObjectWorld = 7,
    Corpse = 8,
    Rider = 9,
    Unconscious = 10,
};

/** Convert database string to TargetType enum */
inline std::optional<TargetType> target_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TargetType> lookup = {
        {"SELF", TargetType::Self},
        {"ALLY_PC", TargetType::AllyPc},
        {"ALLY_NPC", TargetType::AllyNpc},
        {"ALLY_GROUP", TargetType::AllyGroup},
        {"ENEMY_PC", TargetType::EnemyPc},
        {"ENEMY_NPC", TargetType::EnemyNpc},
        {"OBJECT_INV", TargetType::ObjectInv},
        {"OBJECT_WORLD", TargetType::ObjectWorld},
        {"CORPSE", TargetType::Corpse},
        {"RIDER", TargetType::Rider},
        {"UNCONSCIOUS", TargetType::Unconscious},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TargetType enum to database string */
inline std::string_view target_type_to_db(TargetType e) {
    switch (e) {
    case TargetType::Self:
        return "SELF";
    case TargetType::AllyPc:
        return "ALLY_PC";
    case TargetType::AllyNpc:
        return "ALLY_NPC";
    case TargetType::AllyGroup:
        return "ALLY_GROUP";
    case TargetType::EnemyPc:
        return "ENEMY_PC";
    case TargetType::EnemyNpc:
        return "ENEMY_NPC";
    case TargetType::ObjectInv:
        return "OBJECT_INV";
    case TargetType::ObjectWorld:
        return "OBJECT_WORLD";
    case TargetType::Corpse:
        return "CORPSE";
    case TargetType::Rider:
        return "RIDER";
    case TargetType::Unconscious:
        return "UNCONSCIOUS";
    }
    return "";
}

enum class TargetScope {
    Single = 0,
    Room = 1,
    Group = 2,
    Area = 3,
    Chain = 4,
    Cone = 5,
    Line = 6,
    Self = 7,
};

/** Convert database string to TargetScope enum */
inline std::optional<TargetScope> target_scope_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TargetScope> lookup = {
        {"SINGLE", TargetScope::Single}, {"ROOM", TargetScope::Room},   {"GROUP", TargetScope::Group},
        {"AREA", TargetScope::Area},     {"CHAIN", TargetScope::Chain}, {"CONE", TargetScope::Cone},
        {"LINE", TargetScope::Line},     {"SELF", TargetScope::Self},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TargetScope enum to database string */
inline std::string_view target_scope_to_db(TargetScope e) {
    switch (e) {
    case TargetScope::Single:
        return "SINGLE";
    case TargetScope::Room:
        return "ROOM";
    case TargetScope::Group:
        return "GROUP";
    case TargetScope::Area:
        return "AREA";
    case TargetScope::Chain:
        return "CHAIN";
    case TargetScope::Cone:
        return "CONE";
    case TargetScope::Line:
        return "LINE";
    case TargetScope::Self:
        return "SELF";
    }
    return "";
}

enum class SaveType {
    Reflex = 0,
    Fortitude = 1,
    Will = 2,
};

/** Convert database string to SaveType enum */
inline std::optional<SaveType> save_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SaveType> lookup = {
        {"REFLEX", SaveType::Reflex},
        {"FORTITUDE", SaveType::Fortitude},
        {"WILL", SaveType::Will},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SaveType enum to database string */
inline std::string_view save_type_to_db(SaveType e) {
    switch (e) {
    case SaveType::Reflex:
        return "REFLEX";
    case SaveType::Fortitude:
        return "FORTITUDE";
    case SaveType::Will:
        return "WILL";
    }
    return "";
}

enum class SaveResult {
    None = 0,
    Half = 1,
    Negate = 2,
    Reduce25 = 3,
    Custom = 4,
};

/** Convert database string to SaveResult enum */
inline std::optional<SaveResult> save_result_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SaveResult> lookup = {
        {"NONE", SaveResult::None},         {"HALF", SaveResult::Half},     {"NEGATE", SaveResult::Negate},
        {"REDUCE25", SaveResult::Reduce25}, {"CUSTOM", SaveResult::Custom},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SaveResult enum to database string */
inline std::string_view save_result_to_db(SaveResult e) {
    switch (e) {
    case SaveResult::None:
        return "NONE";
    case SaveResult::Half:
        return "HALF";
    case SaveResult::Negate:
        return "NEGATE";
    case SaveResult::Reduce25:
        return "REDUCE25";
    case SaveResult::Custom:
        return "CUSTOM";
    }
    return "";
}

enum class StackingRule {
    Refresh = 0,
    Stack = 1,
    Ignore = 2,
    MaxOnly = 3,
};

/** Convert database string to StackingRule enum */
inline std::optional<StackingRule> stacking_rule_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, StackingRule> lookup = {
        {"REFRESH", StackingRule::Refresh},
        {"STACK", StackingRule::Stack},
        {"IGNORE", StackingRule::Ignore},
        {"MAX_ONLY", StackingRule::MaxOnly},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert StackingRule enum to database string */
inline std::string_view stacking_rule_to_db(StackingRule e) {
    switch (e) {
    case StackingRule::Refresh:
        return "REFRESH";
    case StackingRule::Stack:
        return "STACK";
    case StackingRule::Ignore:
        return "IGNORE";
    case StackingRule::MaxOnly:
        return "MAX_ONLY";
    }
    return "";
}

// ============================================================================
// Shop System
// ============================================================================

enum class ShopFlag {
    WillFight = 0,
    UsesBank = 1,
    WillBankMoney = 2,
    WillStartFight = 3,
};

/** Convert database string to ShopFlag enum */
inline std::optional<ShopFlag> shop_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ShopFlag> lookup = {
        {"WILL_FIGHT", ShopFlag::WillFight},
        {"USES_BANK", ShopFlag::UsesBank},
        {"WILL_BANK_MONEY", ShopFlag::WillBankMoney},
        {"WILL_START_FIGHT", ShopFlag::WillStartFight},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ShopFlag enum to database string */
inline std::string_view shop_flag_to_db(ShopFlag e) {
    switch (e) {
    case ShopFlag::WillFight:
        return "WILL_FIGHT";
    case ShopFlag::UsesBank:
        return "USES_BANK";
    case ShopFlag::WillBankMoney:
        return "WILL_BANK_MONEY";
    case ShopFlag::WillStartFight:
        return "WILL_START_FIGHT";
    }
    return "";
}

enum class ShopTradesWith {
    Alignment = 0,
    Race = 1,
    Class = 2,
    TradeNogood = 3,
    TradeNoevil = 4,
    TradeNoneutral = 5,
    TradeNocleric = 6,
    TradeNothief = 7,
    TradeNowarrior = 8,
};

/** Convert database string to ShopTradesWith enum */
inline std::optional<ShopTradesWith> shop_trades_with_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ShopTradesWith> lookup = {
        {"ALIGNMENT", ShopTradesWith::Alignment},
        {"RACE", ShopTradesWith::Race},
        {"CLASS", ShopTradesWith::Class},
        {"TRADE_NOGOOD", ShopTradesWith::TradeNogood},
        {"TRADE_NOEVIL", ShopTradesWith::TradeNoevil},
        {"TRADE_NONEUTRAL", ShopTradesWith::TradeNoneutral},
        {"TRADE_NOCLERIC", ShopTradesWith::TradeNocleric},
        {"TRADE_NOTHIEF", ShopTradesWith::TradeNothief},
        {"TRADE_NOWARRIOR", ShopTradesWith::TradeNowarrior},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ShopTradesWith enum to database string */
inline std::string_view shop_trades_with_to_db(ShopTradesWith e) {
    switch (e) {
    case ShopTradesWith::Alignment:
        return "ALIGNMENT";
    case ShopTradesWith::Race:
        return "RACE";
    case ShopTradesWith::Class:
        return "CLASS";
    case ShopTradesWith::TradeNogood:
        return "TRADE_NOGOOD";
    case ShopTradesWith::TradeNoevil:
        return "TRADE_NOEVIL";
    case ShopTradesWith::TradeNoneutral:
        return "TRADE_NONEUTRAL";
    case ShopTradesWith::TradeNocleric:
        return "TRADE_NOCLERIC";
    case ShopTradesWith::TradeNothief:
        return "TRADE_NOTHIEF";
    case ShopTradesWith::TradeNowarrior:
        return "TRADE_NOWARRIOR";
    }
    return "";
}

// ============================================================================
// Zone System
// ============================================================================

enum class Climate {
    None = 0,
    Semiarid = 1,
    Arid = 2,
    Oceanic = 3,
    Temperate = 4,
    Subtropical = 5,
    Tropical = 6,
    Subarctic = 7,
    Arctic = 8,
    Alpine = 9,
};

/** Convert database string to Climate enum */
inline std::optional<Climate> climate_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Climate> lookup = {
        {"NONE", Climate::None},         {"SEMIARID", Climate::Semiarid},   {"ARID", Climate::Arid},
        {"OCEANIC", Climate::Oceanic},   {"TEMPERATE", Climate::Temperate}, {"SUBTROPICAL", Climate::Subtropical},
        {"TROPICAL", Climate::Tropical}, {"SUBARCTIC", Climate::Subarctic}, {"ARCTIC", Climate::Arctic},
        {"ALPINE", Climate::Alpine},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Climate enum to database string */
inline std::string_view climate_to_db(Climate e) {
    switch (e) {
    case Climate::None:
        return "NONE";
    case Climate::Semiarid:
        return "SEMIARID";
    case Climate::Arid:
        return "ARID";
    case Climate::Oceanic:
        return "OCEANIC";
    case Climate::Temperate:
        return "TEMPERATE";
    case Climate::Subtropical:
        return "SUBTROPICAL";
    case Climate::Tropical:
        return "TROPICAL";
    case Climate::Subarctic:
        return "SUBARCTIC";
    case Climate::Arctic:
        return "ARCTIC";
    case Climate::Alpine:
        return "ALPINE";
    }
    return "";
}

enum class Hemisphere {
    Northwest = 0,
    Northeast = 1,
    Southwest = 2,
    Southeast = 3,
};

/** Convert database string to Hemisphere enum */
inline std::optional<Hemisphere> hemisphere_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Hemisphere> lookup = {
        {"NORTHWEST", Hemisphere::Northwest},
        {"NORTHEAST", Hemisphere::Northeast},
        {"SOUTHWEST", Hemisphere::Southwest},
        {"SOUTHEAST", Hemisphere::Southeast},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Hemisphere enum to database string */
inline std::string_view hemisphere_to_db(Hemisphere e) {
    switch (e) {
    case Hemisphere::Northwest:
        return "NORTHWEST";
    case Hemisphere::Northeast:
        return "NORTHEAST";
    case Hemisphere::Southwest:
        return "SOUTHWEST";
    case Hemisphere::Southeast:
        return "SOUTHEAST";
    }
    return "";
}

enum class ResetMode {
    Never = 0,
    Empty = 1,
    Normal = 2,
};

/** Convert database string to ResetMode enum */
inline std::optional<ResetMode> reset_mode_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ResetMode> lookup = {
        {"NEVER", ResetMode::Never},
        {"EMPTY", ResetMode::Empty},
        {"NORMAL", ResetMode::Normal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ResetMode enum to database string */
inline std::string_view reset_mode_to_db(ResetMode e) {
    switch (e) {
    case ResetMode::Never:
        return "NEVER";
    case ResetMode::Empty:
        return "EMPTY";
    case ResetMode::Normal:
        return "NORMAL";
    }
    return "";
}

// ============================================================================
// Script System
// ============================================================================

enum class ScriptType {
    Mob = 0,
    Object = 1,
    World = 2,
};

/** Convert database string to ScriptType enum */
inline std::optional<ScriptType> script_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ScriptType> lookup = {
        {"MOB", ScriptType::Mob},
        {"OBJECT", ScriptType::Object},
        {"WORLD", ScriptType::World},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ScriptType enum to database string */
inline std::string_view script_type_to_db(ScriptType e) {
    switch (e) {
    case ScriptType::Mob:
        return "MOB";
    case ScriptType::Object:
        return "OBJECT";
    case ScriptType::World:
        return "WORLD";
    }
    return "";
}

enum class TriggerFlag {
    Global = 0,
    Random = 1,
    Command = 2,
    Load = 3,
    Cast = 4,
    Leave = 5,
    Time = 6,
    Speech = 7,
    Act = 8,
    Death = 9,
    Greet = 10,
    GreetAll = 11,
    Entry = 12,
    Receive = 13,
    Fight = 14,
    HitPercent = 15,
    Bribe = 16,
    Memory = 17,
    Door = 18,
    SpeechTo = 19,
    Look = 20,
    Auto = 21,
    Attack = 22,
    Defend = 23,
    Timer = 24,
    Get = 25,
    Drop = 26,
    Give = 27,
    Wear = 28,
    Remove = 29,
    Use = 30,
    Consume = 31,
    Reset = 32,
    Preentry = 33,
    Postentry = 34,
};

/** Convert database string to TriggerFlag enum */
inline std::optional<TriggerFlag> trigger_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TriggerFlag> lookup = {
        {"GLOBAL", TriggerFlag::Global},
        {"RANDOM", TriggerFlag::Random},
        {"COMMAND", TriggerFlag::Command},
        {"LOAD", TriggerFlag::Load},
        {"CAST", TriggerFlag::Cast},
        {"LEAVE", TriggerFlag::Leave},
        {"TIME", TriggerFlag::Time},
        {"SPEECH", TriggerFlag::Speech},
        {"ACT", TriggerFlag::Act},
        {"DEATH", TriggerFlag::Death},
        {"GREET", TriggerFlag::Greet},
        {"GREET_ALL", TriggerFlag::GreetAll},
        {"ENTRY", TriggerFlag::Entry},
        {"RECEIVE", TriggerFlag::Receive},
        {"FIGHT", TriggerFlag::Fight},
        {"HIT_PERCENT", TriggerFlag::HitPercent},
        {"BRIBE", TriggerFlag::Bribe},
        {"MEMORY", TriggerFlag::Memory},
        {"DOOR", TriggerFlag::Door},
        {"SPEECH_TO", TriggerFlag::SpeechTo},
        {"LOOK", TriggerFlag::Look},
        {"AUTO", TriggerFlag::Auto},
        {"ATTACK", TriggerFlag::Attack},
        {"DEFEND", TriggerFlag::Defend},
        {"TIMER", TriggerFlag::Timer},
        {"GET", TriggerFlag::Get},
        {"DROP", TriggerFlag::Drop},
        {"GIVE", TriggerFlag::Give},
        {"WEAR", TriggerFlag::Wear},
        {"REMOVE", TriggerFlag::Remove},
        {"USE", TriggerFlag::Use},
        {"CONSUME", TriggerFlag::Consume},
        {"RESET", TriggerFlag::Reset},
        {"PREENTRY", TriggerFlag::Preentry},
        {"POSTENTRY", TriggerFlag::Postentry},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TriggerFlag enum to database string */
inline std::string_view trigger_flag_to_db(TriggerFlag e) {
    switch (e) {
    case TriggerFlag::Global:
        return "GLOBAL";
    case TriggerFlag::Random:
        return "RANDOM";
    case TriggerFlag::Command:
        return "COMMAND";
    case TriggerFlag::Load:
        return "LOAD";
    case TriggerFlag::Cast:
        return "CAST";
    case TriggerFlag::Leave:
        return "LEAVE";
    case TriggerFlag::Time:
        return "TIME";
    case TriggerFlag::Speech:
        return "SPEECH";
    case TriggerFlag::Act:
        return "ACT";
    case TriggerFlag::Death:
        return "DEATH";
    case TriggerFlag::Greet:
        return "GREET";
    case TriggerFlag::GreetAll:
        return "GREET_ALL";
    case TriggerFlag::Entry:
        return "ENTRY";
    case TriggerFlag::Receive:
        return "RECEIVE";
    case TriggerFlag::Fight:
        return "FIGHT";
    case TriggerFlag::HitPercent:
        return "HIT_PERCENT";
    case TriggerFlag::Bribe:
        return "BRIBE";
    case TriggerFlag::Memory:
        return "MEMORY";
    case TriggerFlag::Door:
        return "DOOR";
    case TriggerFlag::SpeechTo:
        return "SPEECH_TO";
    case TriggerFlag::Look:
        return "LOOK";
    case TriggerFlag::Auto:
        return "AUTO";
    case TriggerFlag::Attack:
        return "ATTACK";
    case TriggerFlag::Defend:
        return "DEFEND";
    case TriggerFlag::Timer:
        return "TIMER";
    case TriggerFlag::Get:
        return "GET";
    case TriggerFlag::Drop:
        return "DROP";
    case TriggerFlag::Give:
        return "GIVE";
    case TriggerFlag::Wear:
        return "WEAR";
    case TriggerFlag::Remove:
        return "REMOVE";
    case TriggerFlag::Use:
        return "USE";
    case TriggerFlag::Consume:
        return "CONSUME";
    case TriggerFlag::Reset:
        return "RESET";
    case TriggerFlag::Preentry:
        return "PREENTRY";
    case TriggerFlag::Postentry:
        return "POSTENTRY";
    }
    return "";
}

// ============================================================================
// User System
// ============================================================================

enum class UserRole {
    Player = 0,
    Immortal = 1,
    Builder = 2,
    HeadBuilder = 3,
    Coder = 4,
    God = 5,
};

/** Convert database string to UserRole enum */
inline std::optional<UserRole> user_role_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, UserRole> lookup = {
        {"PLAYER", UserRole::Player},   {"IMMORTAL", UserRole::Immortal},
        {"BUILDER", UserRole::Builder}, {"HEAD_BUILDER", UserRole::HeadBuilder},
        {"CODER", UserRole::Coder},     {"GOD", UserRole::God},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert UserRole enum to database string */
inline std::string_view user_role_to_db(UserRole e) {
    switch (e) {
    case UserRole::Player:
        return "PLAYER";
    case UserRole::Immortal:
        return "IMMORTAL";
    case UserRole::Builder:
        return "BUILDER";
    case UserRole::HeadBuilder:
        return "HEAD_BUILDER";
    case UserRole::Coder:
        return "CODER";
    case UserRole::God:
        return "GOD";
    }
    return "";
}

enum class GrantResourceType {
    Zone = 0,
    Mob = 1,
    Object = 2,
    Shop = 3,
};

/** Convert database string to GrantResourceType enum */
inline std::optional<GrantResourceType> grant_resource_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, GrantResourceType> lookup = {
        {"ZONE", GrantResourceType::Zone},
        {"MOB", GrantResourceType::Mob},
        {"OBJECT", GrantResourceType::Object},
        {"SHOP", GrantResourceType::Shop},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert GrantResourceType enum to database string */
inline std::string_view grant_resource_type_to_db(GrantResourceType e) {
    switch (e) {
    case GrantResourceType::Zone:
        return "ZONE";
    case GrantResourceType::Mob:
        return "MOB";
    case GrantResourceType::Object:
        return "OBJECT";
    case GrantResourceType::Shop:
        return "SHOP";
    }
    return "";
}

enum class GrantPermission {
    Read = 0,
    Write = 1,
    Delete = 2,
    Admin = 3,
};

/** Convert database string to GrantPermission enum */
inline std::optional<GrantPermission> grant_permission_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, GrantPermission> lookup = {
        {"READ", GrantPermission::Read},
        {"WRITE", GrantPermission::Write},
        {"DELETE", GrantPermission::Delete},
        {"ADMIN", GrantPermission::Admin},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert GrantPermission enum to database string */
inline std::string_view grant_permission_to_db(GrantPermission e) {
    switch (e) {
    case GrantPermission::Read:
        return "READ";
    case GrantPermission::Write:
        return "WRITE";
    case GrantPermission::Delete:
        return "DELETE";
    case GrantPermission::Admin:
        return "ADMIN";
    }
    return "";
}

// ============================================================================
// Configuration
// ============================================================================

enum class ConfigValueType {
    String = 0,
    Int = 1,
    Float = 2,
    Bool = 3,
    Json = 4,
};

/** Convert database string to ConfigValueType enum */
inline std::optional<ConfigValueType> config_value_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ConfigValueType> lookup = {
        {"STRING", ConfigValueType::String}, {"INT", ConfigValueType::Int},   {"FLOAT", ConfigValueType::Float},
        {"BOOL", ConfigValueType::Bool},     {"JSON", ConfigValueType::Json},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ConfigValueType enum to database string */
inline std::string_view config_value_type_to_db(ConfigValueType e) {
    switch (e) {
    case ConfigValueType::String:
        return "STRING";
    case ConfigValueType::Int:
        return "INT";
    case ConfigValueType::Float:
        return "FLOAT";
    case ConfigValueType::Bool:
        return "BOOL";
    case ConfigValueType::Json:
        return "JSON";
    }
    return "";
}

enum class SystemTextCategory {
    Login = 0,
    System = 1,
    Combat = 2,
    Immortal = 3,
};

/** Convert database string to SystemTextCategory enum */
inline std::optional<SystemTextCategory> system_text_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SystemTextCategory> lookup = {
        {"LOGIN", SystemTextCategory::Login},
        {"SYSTEM", SystemTextCategory::System},
        {"COMBAT", SystemTextCategory::Combat},
        {"IMMORTAL", SystemTextCategory::Immortal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SystemTextCategory enum to database string */
inline std::string_view system_text_category_to_db(SystemTextCategory e) {
    switch (e) {
    case SystemTextCategory::Login:
        return "LOGIN";
    case SystemTextCategory::System:
        return "SYSTEM";
    case SystemTextCategory::Combat:
        return "COMBAT";
    case SystemTextCategory::Immortal:
        return "IMMORTAL";
    }
    return "";
}

enum class LoginStage {
    WelcomeBanner = 0,
    UsernamePrompt = 1,
    PasswordPrompt = 2,
    InvalidLogin = 3,
    TooManyAttempts = 4,
    CharacterSelect = 5,
    CreateNamePrompt = 6,
    CreatePassword = 7,
    ConfirmPassword = 8,
    SelectClass = 9,
    SelectRace = 10,
    CreationComplete = 11,
    ReconnectMessage = 12,
};

/** Convert database string to LoginStage enum */
inline std::optional<LoginStage> login_stage_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, LoginStage> lookup = {
        {"WELCOME_BANNER", LoginStage::WelcomeBanner},
        {"USERNAME_PROMPT", LoginStage::UsernamePrompt},
        {"PASSWORD_PROMPT", LoginStage::PasswordPrompt},
        {"INVALID_LOGIN", LoginStage::InvalidLogin},
        {"TOO_MANY_ATTEMPTS", LoginStage::TooManyAttempts},
        {"CHARACTER_SELECT", LoginStage::CharacterSelect},
        {"CREATE_NAME_PROMPT", LoginStage::CreateNamePrompt},
        {"CREATE_PASSWORD", LoginStage::CreatePassword},
        {"CONFIRM_PASSWORD", LoginStage::ConfirmPassword},
        {"SELECT_CLASS", LoginStage::SelectClass},
        {"SELECT_RACE", LoginStage::SelectRace},
        {"CREATION_COMPLETE", LoginStage::CreationComplete},
        {"RECONNECT_MESSAGE", LoginStage::ReconnectMessage},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert LoginStage enum to database string */
inline std::string_view login_stage_to_db(LoginStage e) {
    switch (e) {
    case LoginStage::WelcomeBanner:
        return "WELCOME_BANNER";
    case LoginStage::UsernamePrompt:
        return "USERNAME_PROMPT";
    case LoginStage::PasswordPrompt:
        return "PASSWORD_PROMPT";
    case LoginStage::InvalidLogin:
        return "INVALID_LOGIN";
    case LoginStage::TooManyAttempts:
        return "TOO_MANY_ATTEMPTS";
    case LoginStage::CharacterSelect:
        return "CHARACTER_SELECT";
    case LoginStage::CreateNamePrompt:
        return "CREATE_NAME_PROMPT";
    case LoginStage::CreatePassword:
        return "CREATE_PASSWORD";
    case LoginStage::ConfirmPassword:
        return "CONFIRM_PASSWORD";
    case LoginStage::SelectClass:
        return "SELECT_CLASS";
    case LoginStage::SelectRace:
        return "SELECT_RACE";
    case LoginStage::CreationComplete:
        return "CREATION_COMPLETE";
    case LoginStage::ReconnectMessage:
        return "RECONNECT_MESSAGE";
    }
    return "";
}

enum class CommandCategory {
    Movement = 0,
    Combat = 1,
    Communication = 2,
    Object = 3,
    Information = 4,
    Social = 5,
    Admin = 6,
    Building = 7,
    System = 8,
    Clan = 9,
    Magic = 10,
    Skills = 11,
};

/** Convert database string to CommandCategory enum */
inline std::optional<CommandCategory> command_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, CommandCategory> lookup = {
        {"MOVEMENT", CommandCategory::Movement},
        {"COMBAT", CommandCategory::Combat},
        {"COMMUNICATION", CommandCategory::Communication},
        {"OBJECT", CommandCategory::Object},
        {"INFORMATION", CommandCategory::Information},
        {"SOCIAL", CommandCategory::Social},
        {"ADMIN", CommandCategory::Admin},
        {"BUILDING", CommandCategory::Building},
        {"SYSTEM", CommandCategory::System},
        {"CLAN", CommandCategory::Clan},
        {"MAGIC", CommandCategory::Magic},
        {"SKILLS", CommandCategory::Skills},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert CommandCategory enum to database string */
inline std::string_view command_category_to_db(CommandCategory e) {
    switch (e) {
    case CommandCategory::Movement:
        return "MOVEMENT";
    case CommandCategory::Combat:
        return "COMBAT";
    case CommandCategory::Communication:
        return "COMMUNICATION";
    case CommandCategory::Object:
        return "OBJECT";
    case CommandCategory::Information:
        return "INFORMATION";
    case CommandCategory::Social:
        return "SOCIAL";
    case CommandCategory::Admin:
        return "ADMIN";
    case CommandCategory::Building:
        return "BUILDING";
    case CommandCategory::System:
        return "SYSTEM";
    case CommandCategory::Clan:
        return "CLAN";
    case CommandCategory::Magic:
        return "MAGIC";
    case CommandCategory::Skills:
        return "SKILLS";
    }
    return "";
}

// ============================================================================
// Other Enums
// ============================================================================

enum class ReportType {
    Bug = 0,
    Idea = 1,
    Typo = 2,
};

/** Convert database string to ReportType enum */
inline std::optional<ReportType> report_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ReportType> lookup = {
        {"BUG", ReportType::Bug},
        {"IDEA", ReportType::Idea},
        {"TYPO", ReportType::Typo},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ReportType enum to database string */
inline std::string_view report_type_to_db(ReportType e) {
    switch (e) {
    case ReportType::Bug:
        return "BUG";
    case ReportType::Idea:
        return "IDEA";
    case ReportType::Typo:
        return "TYPO";
    }
    return "";
}

enum class ReportStatus {
    Open = 0,
    InProgress = 1,
    Resolved = 2,
    WontFix = 3,
    Duplicate = 4,
};

/** Convert database string to ReportStatus enum */
inline std::optional<ReportStatus> report_status_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ReportStatus> lookup = {
        {"OPEN", ReportStatus::Open},           {"IN_PROGRESS", ReportStatus::InProgress},
        {"RESOLVED", ReportStatus::Resolved},   {"WONT_FIX", ReportStatus::WontFix},
        {"DUPLICATE", ReportStatus::Duplicate},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ReportStatus enum to database string */
inline std::string_view report_status_to_db(ReportStatus e) {
    switch (e) {
    case ReportStatus::Open:
        return "OPEN";
    case ReportStatus::InProgress:
        return "IN_PROGRESS";
    case ReportStatus::Resolved:
        return "RESOLVED";
    case ReportStatus::WontFix:
        return "WONT_FIX";
    case ReportStatus::Duplicate:
        return "DUPLICATE";
    }
    return "";
}

enum class MobProfession {
    Banker = 0,
    Shopkeeper = 1,
    Receptionist = 2,
    Postmaster = 3,
    Guildmaster = 4,
    Trainer = 5,
};

/** Convert database string to MobProfession enum */
inline std::optional<MobProfession> mob_profession_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobProfession> lookup = {
        {"BANKER", MobProfession::Banker},
        {"SHOPKEEPER", MobProfession::Shopkeeper},
        {"RECEPTIONIST", MobProfession::Receptionist},
        {"POSTMASTER", MobProfession::Postmaster},
        {"GUILDMASTER", MobProfession::Guildmaster},
        {"TRAINER", MobProfession::Trainer},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobProfession enum to database string */
inline std::string_view mob_profession_to_db(MobProfession e) {
    switch (e) {
    case MobProfession::Banker:
        return "BANKER";
    case MobProfession::Shopkeeper:
        return "SHOPKEEPER";
    case MobProfession::Receptionist:
        return "RECEPTIONIST";
    case MobProfession::Postmaster:
        return "POSTMASTER";
    case MobProfession::Guildmaster:
        return "GUILDMASTER";
    case MobProfession::Trainer:
        return "TRAINER";
    }
    return "";
}

enum class ObjectRestriction {
    NoDrop = 0,
    NoTake = 1,
    NoSell = 2,
    NoBurn = 3,
    NoLocate = 4,
    NoInvisible = 5,
};

/** Convert database string to ObjectRestriction enum */
inline std::optional<ObjectRestriction> object_restriction_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ObjectRestriction> lookup = {
        {"NO_DROP", ObjectRestriction::NoDrop},     {"NO_TAKE", ObjectRestriction::NoTake},
        {"NO_SELL", ObjectRestriction::NoSell},     {"NO_BURN", ObjectRestriction::NoBurn},
        {"NO_LOCATE", ObjectRestriction::NoLocate}, {"NO_INVISIBLE", ObjectRestriction::NoInvisible},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ObjectRestriction enum to database string */
inline std::string_view object_restriction_to_db(ObjectRestriction e) {
    switch (e) {
    case ObjectRestriction::NoDrop:
        return "NO_DROP";
    case ObjectRestriction::NoTake:
        return "NO_TAKE";
    case ObjectRestriction::NoSell:
        return "NO_SELL";
    case ObjectRestriction::NoBurn:
        return "NO_BURN";
    case ObjectRestriction::NoLocate:
        return "NO_LOCATE";
    case ObjectRestriction::NoInvisible:
        return "NO_INVISIBLE";
    }
    return "";
}

enum class MovementMode {
    Normal = 0,
    Flying = 1,
    Swimming = 2,
    Underwater = 3,
    Mounted = 4,
    Ethereal = 5,
};

/** Convert database string to MovementMode enum */
inline std::optional<MovementMode> movement_mode_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MovementMode> lookup = {
        {"NORMAL", MovementMode::Normal},     {"FLYING", MovementMode::Flying},
        {"SWIMMING", MovementMode::Swimming}, {"UNDERWATER", MovementMode::Underwater},
        {"MOUNTED", MovementMode::Mounted},   {"ETHEREAL", MovementMode::Ethereal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MovementMode enum to database string */
inline std::string_view movement_mode_to_db(MovementMode e) {
    switch (e) {
    case MovementMode::Normal:
        return "NORMAL";
    case MovementMode::Flying:
        return "FLYING";
    case MovementMode::Swimming:
        return "SWIMMING";
    case MovementMode::Underwater:
        return "UNDERWATER";
    case MovementMode::Mounted:
        return "MOUNTED";
    case MovementMode::Ethereal:
        return "ETHEREAL";
    }
    return "";
}

enum class PositionMechanic {
    Ground = 0,
    Aerial = 1,
    Aquatic = 2,
    Submerged = 3,
    Ethereal = 4,
    Mounted = 5,
    Incapacitated = 6,
};

/** Convert database string to PositionMechanic enum */
inline std::optional<PositionMechanic> position_mechanic_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, PositionMechanic> lookup = {
        {"GROUND", PositionMechanic::Ground},
        {"AERIAL", PositionMechanic::Aerial},
        {"AQUATIC", PositionMechanic::Aquatic},
        {"SUBMERGED", PositionMechanic::Submerged},
        {"ETHEREAL", PositionMechanic::Ethereal},
        {"MOUNTED", PositionMechanic::Mounted},
        {"INCAPACITATED", PositionMechanic::Incapacitated},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert PositionMechanic enum to database string */
inline std::string_view position_mechanic_to_db(PositionMechanic e) {
    switch (e) {
    case PositionMechanic::Ground:
        return "GROUND";
    case PositionMechanic::Aerial:
        return "AERIAL";
    case PositionMechanic::Aquatic:
        return "AQUATIC";
    case PositionMechanic::Submerged:
        return "SUBMERGED";
    case PositionMechanic::Ethereal:
        return "ETHEREAL";
    case PositionMechanic::Mounted:
        return "MOUNTED";
    case PositionMechanic::Incapacitated:
        return "INCAPACITATED";
    }
    return "";
}

enum class PlayerFlag {
    Brief = 0,
    Compact = 1,
    NoRepeat = 2,
    AutoLoot = 3,
    AutoGold = 4,
    AutoSplit = 5,
    AutoExit = 6,
    AutoAssist = 7,
    Wimpy = 8,
    ShowDiceRolls = 9,
    Afk = 10,
    Deaf = 11,
    NoTell = 12,
    NoSummon = 13,
    Quest = 14,
    PkEnabled = 15,
    Consent = 16,
    ColorBlind = 17,
    Msp = 18,
    MxpEnabled = 19,
    HolyLight = 20,
    ShowIds = 21,
};

/** Convert database string to PlayerFlag enum */
inline std::optional<PlayerFlag> player_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, PlayerFlag> lookup = {
        {"BRIEF", PlayerFlag::Brief},
        {"COMPACT", PlayerFlag::Compact},
        {"NO_REPEAT", PlayerFlag::NoRepeat},
        {"AUTO_LOOT", PlayerFlag::AutoLoot},
        {"AUTO_GOLD", PlayerFlag::AutoGold},
        {"AUTO_SPLIT", PlayerFlag::AutoSplit},
        {"AUTO_EXIT", PlayerFlag::AutoExit},
        {"AUTO_ASSIST", PlayerFlag::AutoAssist},
        {"WIMPY", PlayerFlag::Wimpy},
        {"SHOW_DICE_ROLLS", PlayerFlag::ShowDiceRolls},
        {"AFK", PlayerFlag::Afk},
        {"DEAF", PlayerFlag::Deaf},
        {"NO_TELL", PlayerFlag::NoTell},
        {"NO_SUMMON", PlayerFlag::NoSummon},
        {"QUEST", PlayerFlag::Quest},
        {"PK_ENABLED", PlayerFlag::PkEnabled},
        {"CONSENT", PlayerFlag::Consent},
        {"COLOR_BLIND", PlayerFlag::ColorBlind},
        {"MSP", PlayerFlag::Msp},
        {"MXP_ENABLED", PlayerFlag::MxpEnabled},
        {"HOLY_LIGHT", PlayerFlag::HolyLight},
        {"SHOW_IDS", PlayerFlag::ShowIds},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert PlayerFlag enum to database string */
inline std::string_view player_flag_to_db(PlayerFlag e) {
    switch (e) {
    case PlayerFlag::Brief:
        return "BRIEF";
    case PlayerFlag::Compact:
        return "COMPACT";
    case PlayerFlag::NoRepeat:
        return "NO_REPEAT";
    case PlayerFlag::AutoLoot:
        return "AUTO_LOOT";
    case PlayerFlag::AutoGold:
        return "AUTO_GOLD";
    case PlayerFlag::AutoSplit:
        return "AUTO_SPLIT";
    case PlayerFlag::AutoExit:
        return "AUTO_EXIT";
    case PlayerFlag::AutoAssist:
        return "AUTO_ASSIST";
    case PlayerFlag::Wimpy:
        return "WIMPY";
    case PlayerFlag::ShowDiceRolls:
        return "SHOW_DICE_ROLLS";
    case PlayerFlag::Afk:
        return "AFK";
    case PlayerFlag::Deaf:
        return "DEAF";
    case PlayerFlag::NoTell:
        return "NO_TELL";
    case PlayerFlag::NoSummon:
        return "NO_SUMMON";
    case PlayerFlag::Quest:
        return "QUEST";
    case PlayerFlag::PkEnabled:
        return "PK_ENABLED";
    case PlayerFlag::Consent:
        return "CONSENT";
    case PlayerFlag::ColorBlind:
        return "COLOR_BLIND";
    case PlayerFlag::Msp:
        return "MSP";
    case PlayerFlag::MxpEnabled:
        return "MXP_ENABLED";
    case PlayerFlag::HolyLight:
        return "HOLY_LIGHT";
    case PlayerFlag::ShowIds:
        return "SHOW_IDS";
    }
    return "";
}

enum class Permission {
    Build = 0,
    Code = 1,
    Admin = 2,
    God = 3,
    Shutdown = 4,
    Wizlock = 5,
    Syslog = 6,
    Log = 7,
    Force = 8,
    Snoop = 9,
    Freeze = 10,
    Thaw = 11,
    Ban = 12,
    Unban = 13,
    Dc = 14,
    Advance = 15,
    Restore = 16,
    Notitle = 17,
    Squelch = 18,
    Teleport = 19,
    Transfer = 20,
    Summon = 21,
    Invisible = 22,
    Nohassle = 23,
    ZoneReset = 24,
    Wiznet = 25,
    Olc = 26,
};

/** Convert database string to Permission enum */
inline std::optional<Permission> permission_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Permission> lookup = {
        {"BUILD", Permission::Build},
        {"CODE", Permission::Code},
        {"ADMIN", Permission::Admin},
        {"GOD", Permission::God},
        {"SHUTDOWN", Permission::Shutdown},
        {"WIZLOCK", Permission::Wizlock},
        {"SYSLOG", Permission::Syslog},
        {"LOG", Permission::Log},
        {"FORCE", Permission::Force},
        {"SNOOP", Permission::Snoop},
        {"FREEZE", Permission::Freeze},
        {"THAW", Permission::Thaw},
        {"BAN", Permission::Ban},
        {"UNBAN", Permission::Unban},
        {"DC", Permission::Dc},
        {"ADVANCE", Permission::Advance},
        {"RESTORE", Permission::Restore},
        {"NOTITLE", Permission::Notitle},
        {"SQUELCH", Permission::Squelch},
        {"TELEPORT", Permission::Teleport},
        {"TRANSFER", Permission::Transfer},
        {"SUMMON", Permission::Summon},
        {"INVISIBLE", Permission::Invisible},
        {"NOHASSLE", Permission::Nohassle},
        {"ZONE_RESET", Permission::ZoneReset},
        {"WIZNET", Permission::Wiznet},
        {"OLC", Permission::Olc},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Permission enum to database string */
inline std::string_view permission_to_db(Permission e) {
    switch (e) {
    case Permission::Build:
        return "BUILD";
    case Permission::Code:
        return "CODE";
    case Permission::Admin:
        return "ADMIN";
    case Permission::God:
        return "GOD";
    case Permission::Shutdown:
        return "SHUTDOWN";
    case Permission::Wizlock:
        return "WIZLOCK";
    case Permission::Syslog:
        return "SYSLOG";
    case Permission::Log:
        return "LOG";
    case Permission::Force:
        return "FORCE";
    case Permission::Snoop:
        return "SNOOP";
    case Permission::Freeze:
        return "FREEZE";
    case Permission::Thaw:
        return "THAW";
    case Permission::Ban:
        return "BAN";
    case Permission::Unban:
        return "UNBAN";
    case Permission::Dc:
        return "DC";
    case Permission::Advance:
        return "ADVANCE";
    case Permission::Restore:
        return "RESTORE";
    case Permission::Notitle:
        return "NOTITLE";
    case Permission::Squelch:
        return "SQUELCH";
    case Permission::Teleport:
        return "TELEPORT";
    case Permission::Transfer:
        return "TRANSFER";
    case Permission::Summon:
        return "SUMMON";
    case Permission::Invisible:
        return "INVISIBLE";
    case Permission::Nohassle:
        return "NOHASSLE";
    case Permission::ZoneReset:
        return "ZONE_RESET";
    case Permission::Wiznet:
        return "WIZNET";
    case Permission::Olc:
        return "OLC";
    }
    return "";
}

enum class ItemInstanceFlag {
    Identified = 0,
    CursedKnown = 1,
    Attuned = 2,
    CustomNamed = 3,
    CustomDescribed = 4,
    Stolen = 5,
    QuestFlagged = 6,
    Heirloom = 7,
};

/** Convert database string to ItemInstanceFlag enum */
inline std::optional<ItemInstanceFlag> item_instance_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ItemInstanceFlag> lookup = {
        {"IDENTIFIED", ItemInstanceFlag::Identified},
        {"CURSED_KNOWN", ItemInstanceFlag::CursedKnown},
        {"ATTUNED", ItemInstanceFlag::Attuned},
        {"CUSTOM_NAMED", ItemInstanceFlag::CustomNamed},
        {"CUSTOM_DESCRIBED", ItemInstanceFlag::CustomDescribed},
        {"STOLEN", ItemInstanceFlag::Stolen},
        {"QUEST_FLAGGED", ItemInstanceFlag::QuestFlagged},
        {"HEIRLOOM", ItemInstanceFlag::Heirloom},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ItemInstanceFlag enum to database string */
inline std::string_view item_instance_flag_to_db(ItemInstanceFlag e) {
    switch (e) {
    case ItemInstanceFlag::Identified:
        return "IDENTIFIED";
    case ItemInstanceFlag::CursedKnown:
        return "CURSED_KNOWN";
    case ItemInstanceFlag::Attuned:
        return "ATTUNED";
    case ItemInstanceFlag::CustomNamed:
        return "CUSTOM_NAMED";
    case ItemInstanceFlag::CustomDescribed:
        return "CUSTOM_DESCRIBED";
    case ItemInstanceFlag::Stolen:
        return "STOLEN";
    case ItemInstanceFlag::QuestFlagged:
        return "QUEST_FLAGGED";
    case ItemInstanceFlag::Heirloom:
        return "HEIRLOOM";
    }
    return "";
}

enum class ToggleCategory {
    Display = 0,
    Combat = 1,
    Social = 2,
    Immortal = 3,
};

/** Convert database string to ToggleCategory enum */
inline std::optional<ToggleCategory> toggle_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ToggleCategory> lookup = {
        {"DISPLAY", ToggleCategory::Display},
        {"COMBAT", ToggleCategory::Combat},
        {"SOCIAL", ToggleCategory::Social},
        {"IMMORTAL", ToggleCategory::Immortal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ToggleCategory enum to database string */
inline std::string_view toggle_category_to_db(ToggleCategory e) {
    switch (e) {
    case ToggleCategory::Display:
        return "DISPLAY";
    case ToggleCategory::Combat:
        return "COMBAT";
    case ToggleCategory::Social:
        return "SOCIAL";
    case ToggleCategory::Immortal:
        return "IMMORTAL";
    }
    return "";
}

enum class HitType {
    Miss = 0,
    Glancing = 1,
    Hit = 2,
    Critical = 3,
    Death = 4,
    Dodge = 5,
    Parry = 6,
    Block = 7,
};

/** Convert database string to HitType enum */
inline std::optional<HitType> hit_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, HitType> lookup = {
        {"MISS", HitType::Miss},         {"GLANCING", HitType::Glancing}, {"HIT", HitType::Hit},
        {"CRITICAL", HitType::Critical}, {"DEATH", HitType::Death},       {"DODGE", HitType::Dodge},
        {"PARRY", HitType::Parry},       {"BLOCK", HitType::Block},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert HitType enum to database string */
inline std::string_view hit_type_to_db(HitType e) {
    switch (e) {
    case HitType::Miss:
        return "MISS";
    case HitType::Glancing:
        return "GLANCING";
    case HitType::Hit:
        return "HIT";
    case HitType::Critical:
        return "CRITICAL";
    case HitType::Death:
        return "DEATH";
    case HitType::Dodge:
        return "DODGE";
    case HitType::Parry:
        return "PARRY";
    case HitType::Block:
        return "BLOCK";
    }
    return "";
}

enum class QuestObjectiveType {
    KillMob = 0,
    CollectItem = 1,
    DeliverItem = 2,
    VisitRoom = 3,
    TalkToNpc = 4,
    UseSkill = 5,
    CustomLua = 6,
};

/** Convert database string to QuestObjectiveType enum */
inline std::optional<QuestObjectiveType> quest_objective_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, QuestObjectiveType> lookup = {
        {"KILL_MOB", QuestObjectiveType::KillMob},         {"COLLECT_ITEM", QuestObjectiveType::CollectItem},
        {"DELIVER_ITEM", QuestObjectiveType::DeliverItem}, {"VISIT_ROOM", QuestObjectiveType::VisitRoom},
        {"TALK_TO_NPC", QuestObjectiveType::TalkToNpc},    {"USE_SKILL", QuestObjectiveType::UseSkill},
        {"CUSTOM_LUA", QuestObjectiveType::CustomLua},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert QuestObjectiveType enum to database string */
inline std::string_view quest_objective_type_to_db(QuestObjectiveType e) {
    switch (e) {
    case QuestObjectiveType::KillMob:
        return "KILL_MOB";
    case QuestObjectiveType::CollectItem:
        return "COLLECT_ITEM";
    case QuestObjectiveType::DeliverItem:
        return "DELIVER_ITEM";
    case QuestObjectiveType::VisitRoom:
        return "VISIT_ROOM";
    case QuestObjectiveType::TalkToNpc:
        return "TALK_TO_NPC";
    case QuestObjectiveType::UseSkill:
        return "USE_SKILL";
    case QuestObjectiveType::CustomLua:
        return "CUSTOM_LUA";
    }
    return "";
}

enum class QuestRewardType {
    Experience = 0,
    Item = 1,
    Gold = 2,
    Ability = 3,
    SkillPoints = 4,
};

/** Convert database string to QuestRewardType enum */
inline std::optional<QuestRewardType> quest_reward_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, QuestRewardType> lookup = {
        {"EXPERIENCE", QuestRewardType::Experience},
        {"ITEM", QuestRewardType::Item},
        {"GOLD", QuestRewardType::Gold},
        {"ABILITY", QuestRewardType::Ability},
        {"SKILL_POINTS", QuestRewardType::SkillPoints},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert QuestRewardType enum to database string */
inline std::string_view quest_reward_type_to_db(QuestRewardType e) {
    switch (e) {
    case QuestRewardType::Experience:
        return "EXPERIENCE";
    case QuestRewardType::Item:
        return "ITEM";
    case QuestRewardType::Gold:
        return "GOLD";
    case QuestRewardType::Ability:
        return "ABILITY";
    case QuestRewardType::SkillPoints:
        return "SKILL_POINTS";
    }
    return "";
}

enum class QuestStatus {
    Available = 0,
    InProgress = 1,
    Completed = 2,
    Failed = 3,
    Abandoned = 4,
};

/** Convert database string to QuestStatus enum */
inline std::optional<QuestStatus> quest_status_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, QuestStatus> lookup = {
        {"AVAILABLE", QuestStatus::Available}, {"IN_PROGRESS", QuestStatus::InProgress},
        {"COMPLETED", QuestStatus::Completed}, {"FAILED", QuestStatus::Failed},
        {"ABANDONED", QuestStatus::Abandoned},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert QuestStatus enum to database string */
inline std::string_view quest_status_to_db(QuestStatus e) {
    switch (e) {
    case QuestStatus::Available:
        return "AVAILABLE";
    case QuestStatus::InProgress:
        return "IN_PROGRESS";
    case QuestStatus::Completed:
        return "COMPLETED";
    case QuestStatus::Failed:
        return "FAILED";
    case QuestStatus::Abandoned:
        return "ABANDONED";
    }
    return "";
}

enum class DialogueMatchType {
    Exact = 0,
    Contains = 1,
    StartsWith = 2,
    AnyResponse = 3,
    AnyOf = 4,
    Regex = 5,
};

/** Convert database string to DialogueMatchType enum */
inline std::optional<DialogueMatchType> dialogue_match_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, DialogueMatchType> lookup = {
        {"EXACT", DialogueMatchType::Exact},
        {"CONTAINS", DialogueMatchType::Contains},
        {"STARTS_WITH", DialogueMatchType::StartsWith},
        {"ANY_RESPONSE", DialogueMatchType::AnyResponse},
        {"ANY_OF", DialogueMatchType::AnyOf},
        {"REGEX", DialogueMatchType::Regex},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert DialogueMatchType enum to database string */
inline std::string_view dialogue_match_type_to_db(DialogueMatchType e) {
    switch (e) {
    case DialogueMatchType::Exact:
        return "EXACT";
    case DialogueMatchType::Contains:
        return "CONTAINS";
    case DialogueMatchType::StartsWith:
        return "STARTS_WITH";
    case DialogueMatchType::AnyResponse:
        return "ANY_RESPONSE";
    case DialogueMatchType::AnyOf:
        return "ANY_OF";
    case DialogueMatchType::Regex:
        return "REGEX";
    }
    return "";
}

enum class QuestTriggerType {
    Mob = 0,
    Level = 1,
    Item = 2,
    Room = 3,
    Skill = 4,
    Event = 5,
    Auto = 6,
    Manual = 7,
};

/** Convert database string to QuestTriggerType enum */
inline std::optional<QuestTriggerType> quest_trigger_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, QuestTriggerType> lookup = {
        {"MOB", QuestTriggerType::Mob},   {"LEVEL", QuestTriggerType::Level},   {"ITEM", QuestTriggerType::Item},
        {"ROOM", QuestTriggerType::Room}, {"SKILL", QuestTriggerType::Skill},   {"EVENT", QuestTriggerType::Event},
        {"AUTO", QuestTriggerType::Auto}, {"MANUAL", QuestTriggerType::Manual},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert QuestTriggerType enum to database string */
inline std::string_view quest_trigger_type_to_db(QuestTriggerType e) {
    switch (e) {
    case QuestTriggerType::Mob:
        return "MOB";
    case QuestTriggerType::Level:
        return "LEVEL";
    case QuestTriggerType::Item:
        return "ITEM";
    case QuestTriggerType::Room:
        return "ROOM";
    case QuestTriggerType::Skill:
        return "SKILL";
    case QuestTriggerType::Event:
        return "EVENT";
    case QuestTriggerType::Auto:
        return "AUTO";
    case QuestTriggerType::Manual:
        return "MANUAL";
    }
    return "";
}

} // namespace db
