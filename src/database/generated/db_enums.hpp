#pragma once
/**
 * @file db_enums.hpp
 * @brief Database enum definitions auto-generated from Prisma schema.
 *
 * DO NOT EDIT MANUALLY - Generated by scripts/generate_db_headers.py
 * Source: muditor/packages/db/prisma/schema.prisma
 * Generated: 2025-12-27T02:46:16.212920
 */

#include <string_view>
#include <optional>
#include <unordered_map>

namespace db {

// ============================================================================
// Room System
// ============================================================================

enum class RoomFlag {
    Dark = 0,
    Death = 1,
    NoMob = 2,
    Indoors = 3,
    Peaceful = 4,
    Soundproof = 5,
    NoTrack = 6,
    NoMagic = 7,
    Tunnel = 8,
    Private = 9,
    Godroom = 10,
    House = 11,
    Housecrash = 12,
    Atrium = 13,
    Olc = 14,
    BfsMark = 15,
    Worldmap = 16,
    FerryDest = 17,
    Isolated = 18,
    Arena = 19,
    Large = 20,
    MediumLarge = 21,
    Medium = 22,
    MediumSmall = 23,
    Small = 24,
    VerySmall = 25,
    OnePerson = 26,
    EffectsNext = 27,
    AlwaysLit = 28,
    Guildhall = 29,
    NoWell = 30,
    NoSummon = 31,
    NoScan = 32,
    Underdark = 33,
    NoShift = 34,
    NoRecall = 35,
    AltExit = 36,
    Observatory = 37,
    Inn = 38,
    Temple = 39,
    Campsite = 40,
};

/** Convert database string to RoomFlag enum */
inline std::optional<RoomFlag> room_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, RoomFlag> lookup = {
        {"DARK", RoomFlag::Dark},
        {"DEATH", RoomFlag::Death},
        {"NO_MOB", RoomFlag::NoMob},
        {"INDOORS", RoomFlag::Indoors},
        {"PEACEFUL", RoomFlag::Peaceful},
        {"SOUNDPROOF", RoomFlag::Soundproof},
        {"NO_TRACK", RoomFlag::NoTrack},
        {"NO_MAGIC", RoomFlag::NoMagic},
        {"TUNNEL", RoomFlag::Tunnel},
        {"PRIVATE", RoomFlag::Private},
        {"GODROOM", RoomFlag::Godroom},
        {"HOUSE", RoomFlag::House},
        {"HOUSECRASH", RoomFlag::Housecrash},
        {"ATRIUM", RoomFlag::Atrium},
        {"OLC", RoomFlag::Olc},
        {"BFS_MARK", RoomFlag::BfsMark},
        {"WORLDMAP", RoomFlag::Worldmap},
        {"FERRY_DEST", RoomFlag::FerryDest},
        {"ISOLATED", RoomFlag::Isolated},
        {"ARENA", RoomFlag::Arena},
        {"LARGE", RoomFlag::Large},
        {"MEDIUM_LARGE", RoomFlag::MediumLarge},
        {"MEDIUM", RoomFlag::Medium},
        {"MEDIUM_SMALL", RoomFlag::MediumSmall},
        {"SMALL", RoomFlag::Small},
        {"VERY_SMALL", RoomFlag::VerySmall},
        {"ONE_PERSON", RoomFlag::OnePerson},
        {"EFFECTS_NEXT", RoomFlag::EffectsNext},
        {"ALWAYS_LIT", RoomFlag::AlwaysLit},
        {"GUILDHALL", RoomFlag::Guildhall},
        {"NO_WELL", RoomFlag::NoWell},
        {"NO_SUMMON", RoomFlag::NoSummon},
        {"NO_SCAN", RoomFlag::NoScan},
        {"UNDERDARK", RoomFlag::Underdark},
        {"NO_SHIFT", RoomFlag::NoShift},
        {"NO_RECALL", RoomFlag::NoRecall},
        {"ALT_EXIT", RoomFlag::AltExit},
        {"OBSERVATORY", RoomFlag::Observatory},
        {"INN", RoomFlag::Inn},
        {"TEMPLE", RoomFlag::Temple},
        {"CAMPSITE", RoomFlag::Campsite},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert RoomFlag enum to database string */
inline std::string_view room_flag_to_db(RoomFlag e) {
    switch (e) {
        case RoomFlag::Dark: return "DARK";
        case RoomFlag::Death: return "DEATH";
        case RoomFlag::NoMob: return "NO_MOB";
        case RoomFlag::Indoors: return "INDOORS";
        case RoomFlag::Peaceful: return "PEACEFUL";
        case RoomFlag::Soundproof: return "SOUNDPROOF";
        case RoomFlag::NoTrack: return "NO_TRACK";
        case RoomFlag::NoMagic: return "NO_MAGIC";
        case RoomFlag::Tunnel: return "TUNNEL";
        case RoomFlag::Private: return "PRIVATE";
        case RoomFlag::Godroom: return "GODROOM";
        case RoomFlag::House: return "HOUSE";
        case RoomFlag::Housecrash: return "HOUSECRASH";
        case RoomFlag::Atrium: return "ATRIUM";
        case RoomFlag::Olc: return "OLC";
        case RoomFlag::BfsMark: return "BFS_MARK";
        case RoomFlag::Worldmap: return "WORLDMAP";
        case RoomFlag::FerryDest: return "FERRY_DEST";
        case RoomFlag::Isolated: return "ISOLATED";
        case RoomFlag::Arena: return "ARENA";
        case RoomFlag::Large: return "LARGE";
        case RoomFlag::MediumLarge: return "MEDIUM_LARGE";
        case RoomFlag::Medium: return "MEDIUM";
        case RoomFlag::MediumSmall: return "MEDIUM_SMALL";
        case RoomFlag::Small: return "SMALL";
        case RoomFlag::VerySmall: return "VERY_SMALL";
        case RoomFlag::OnePerson: return "ONE_PERSON";
        case RoomFlag::EffectsNext: return "EFFECTS_NEXT";
        case RoomFlag::AlwaysLit: return "ALWAYS_LIT";
        case RoomFlag::Guildhall: return "GUILDHALL";
        case RoomFlag::NoWell: return "NO_WELL";
        case RoomFlag::NoSummon: return "NO_SUMMON";
        case RoomFlag::NoScan: return "NO_SCAN";
        case RoomFlag::Underdark: return "UNDERDARK";
        case RoomFlag::NoShift: return "NO_SHIFT";
        case RoomFlag::NoRecall: return "NO_RECALL";
        case RoomFlag::AltExit: return "ALT_EXIT";
        case RoomFlag::Observatory: return "OBSERVATORY";
        case RoomFlag::Inn: return "INN";
        case RoomFlag::Temple: return "TEMPLE";
        case RoomFlag::Campsite: return "CAMPSITE";
    }
    return "";
}

enum class Sector {
    Structure = 0,
    City = 1,
    Field = 2,
    Forest = 3,
    Hills = 4,
    Mountain = 5,
    Shallows = 6,
    Water = 7,
    Underwater = 8,
    Air = 9,
    Road = 10,
    Grasslands = 11,
    Cave = 12,
    Ruins = 13,
    Swamp = 14,
    Beach = 15,
    Underdark = 16,
    Astralplane = 17,
    Airplane = 18,
    Fireplane = 19,
    Earthplane = 20,
    Etherealplane = 21,
    Avernus = 22,
};

/** Convert database string to Sector enum */
inline std::optional<Sector> sector_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Sector> lookup = {
        {"STRUCTURE", Sector::Structure},
        {"CITY", Sector::City},
        {"FIELD", Sector::Field},
        {"FOREST", Sector::Forest},
        {"HILLS", Sector::Hills},
        {"MOUNTAIN", Sector::Mountain},
        {"SHALLOWS", Sector::Shallows},
        {"WATER", Sector::Water},
        {"UNDERWATER", Sector::Underwater},
        {"AIR", Sector::Air},
        {"ROAD", Sector::Road},
        {"GRASSLANDS", Sector::Grasslands},
        {"CAVE", Sector::Cave},
        {"RUINS", Sector::Ruins},
        {"SWAMP", Sector::Swamp},
        {"BEACH", Sector::Beach},
        {"UNDERDARK", Sector::Underdark},
        {"ASTRALPLANE", Sector::Astralplane},
        {"AIRPLANE", Sector::Airplane},
        {"FIREPLANE", Sector::Fireplane},
        {"EARTHPLANE", Sector::Earthplane},
        {"ETHEREALPLANE", Sector::Etherealplane},
        {"AVERNUS", Sector::Avernus},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Sector enum to database string */
inline std::string_view sector_to_db(Sector e) {
    switch (e) {
        case Sector::Structure: return "STRUCTURE";
        case Sector::City: return "CITY";
        case Sector::Field: return "FIELD";
        case Sector::Forest: return "FOREST";
        case Sector::Hills: return "HILLS";
        case Sector::Mountain: return "MOUNTAIN";
        case Sector::Shallows: return "SHALLOWS";
        case Sector::Water: return "WATER";
        case Sector::Underwater: return "UNDERWATER";
        case Sector::Air: return "AIR";
        case Sector::Road: return "ROAD";
        case Sector::Grasslands: return "GRASSLANDS";
        case Sector::Cave: return "CAVE";
        case Sector::Ruins: return "RUINS";
        case Sector::Swamp: return "SWAMP";
        case Sector::Beach: return "BEACH";
        case Sector::Underdark: return "UNDERDARK";
        case Sector::Astralplane: return "ASTRALPLANE";
        case Sector::Airplane: return "AIRPLANE";
        case Sector::Fireplane: return "FIREPLANE";
        case Sector::Earthplane: return "EARTHPLANE";
        case Sector::Etherealplane: return "ETHEREALPLANE";
        case Sector::Avernus: return "AVERNUS";
    }
    return "";
}

enum class Direction {
    North = 0,
    East = 1,
    South = 2,
    West = 3,
    Up = 4,
    Down = 5,
    Northeast = 6,
    Northwest = 7,
    Southeast = 8,
    Southwest = 9,
    In = 10,
    Out = 11,
    Portal = 12,
    None = 13,
};

/** Convert database string to Direction enum */
inline std::optional<Direction> direction_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Direction> lookup = {
        {"NORTH", Direction::North},
        {"EAST", Direction::East},
        {"SOUTH", Direction::South},
        {"WEST", Direction::West},
        {"UP", Direction::Up},
        {"DOWN", Direction::Down},
        {"NORTHEAST", Direction::Northeast},
        {"NORTHWEST", Direction::Northwest},
        {"SOUTHEAST", Direction::Southeast},
        {"SOUTHWEST", Direction::Southwest},
        {"IN", Direction::In},
        {"OUT", Direction::Out},
        {"PORTAL", Direction::Portal},
        {"NONE", Direction::None},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Direction enum to database string */
inline std::string_view direction_to_db(Direction e) {
    switch (e) {
        case Direction::North: return "NORTH";
        case Direction::East: return "EAST";
        case Direction::South: return "SOUTH";
        case Direction::West: return "WEST";
        case Direction::Up: return "UP";
        case Direction::Down: return "DOWN";
        case Direction::Northeast: return "NORTHEAST";
        case Direction::Northwest: return "NORTHWEST";
        case Direction::Southeast: return "SOUTHEAST";
        case Direction::Southwest: return "SOUTHWEST";
        case Direction::In: return "IN";
        case Direction::Out: return "OUT";
        case Direction::Portal: return "PORTAL";
        case Direction::None: return "NONE";
    }
    return "";
}

enum class ExitFlag {
    IsDoor = 0,
    Closed = 1,
    Locked = 2,
    Pickproof = 3,
    Hidden = 4,
};

/** Convert database string to ExitFlag enum */
inline std::optional<ExitFlag> exit_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ExitFlag> lookup = {
        {"IS_DOOR", ExitFlag::IsDoor},
        {"CLOSED", ExitFlag::Closed},
        {"LOCKED", ExitFlag::Locked},
        {"PICKPROOF", ExitFlag::Pickproof},
        {"HIDDEN", ExitFlag::Hidden},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ExitFlag enum to database string */
inline std::string_view exit_flag_to_db(ExitFlag e) {
    switch (e) {
        case ExitFlag::IsDoor: return "IS_DOOR";
        case ExitFlag::Closed: return "CLOSED";
        case ExitFlag::Locked: return "LOCKED";
        case ExitFlag::Pickproof: return "PICKPROOF";
        case ExitFlag::Hidden: return "HIDDEN";
    }
    return "";
}

// ============================================================================
// Mob System
// ============================================================================

enum class MobFlag {
    Spec = 0,
    Sentinel = 1,
    Scavenger = 2,
    IsNpc = 3,
    Aware = 4,
    Aggressive = 5,
    StayZone = 6,
    Wimpy = 7,
    AggroEvil = 8,
    AggroGood = 9,
    AggroNeutral = 10,
    Memory = 11,
    Helper = 12,
    NoCharm = 13,
    NoSummon = 14,
    NoSleep = 15,
    NoBash = 16,
    NoBlind = 17,
    Mount = 18,
    StaySect = 19,
    HatesSun = 20,
    NoKill = 21,
    Track = 22,
    Illusion = 23,
    PoisonBite = 24,
    Thief = 25,
    Warrior = 26,
    Sorcerer = 27,
    Cleric = 28,
    Paladin = 29,
    AntiPaladin = 30,
    Ranger = 31,
    Druid = 32,
    Shaman = 33,
    Assassin = 34,
    Mercenary = 35,
    Necromancer = 36,
    Conjurer = 37,
    Monk = 38,
    Berserker = 39,
    Diabolist = 40,
    SlowTrack = 41,
    NoSilence = 42,
    Peaceful = 43,
    Protector = 44,
    Peacekeeper = 45,
    Haste = 46,
    Blur = 47,
    Teacher = 48,
    Mountable = 49,
    NoVicious = 50,
    NoClassAi = 51,
    FastTrack = 52,
    Aquatic = 53,
    NoEqRestrict = 54,
    SummonedMount = 55,
    NoPoison = 56,
    Banker = 57,
    Receptionist = 58,
    Postmaster = 59,
};

/** Convert database string to MobFlag enum */
inline std::optional<MobFlag> mob_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobFlag> lookup = {
        {"SPEC", MobFlag::Spec},
        {"SENTINEL", MobFlag::Sentinel},
        {"SCAVENGER", MobFlag::Scavenger},
        {"IS_NPC", MobFlag::IsNpc},
        {"AWARE", MobFlag::Aware},
        {"AGGRESSIVE", MobFlag::Aggressive},
        {"STAY_ZONE", MobFlag::StayZone},
        {"WIMPY", MobFlag::Wimpy},
        {"AGGRO_EVIL", MobFlag::AggroEvil},
        {"AGGRO_GOOD", MobFlag::AggroGood},
        {"AGGRO_NEUTRAL", MobFlag::AggroNeutral},
        {"MEMORY", MobFlag::Memory},
        {"HELPER", MobFlag::Helper},
        {"NO_CHARM", MobFlag::NoCharm},
        {"NO_SUMMON", MobFlag::NoSummon},
        {"NO_SLEEP", MobFlag::NoSleep},
        {"NO_BASH", MobFlag::NoBash},
        {"NO_BLIND", MobFlag::NoBlind},
        {"MOUNT", MobFlag::Mount},
        {"STAY_SECT", MobFlag::StaySect},
        {"HATES_SUN", MobFlag::HatesSun},
        {"NO_KILL", MobFlag::NoKill},
        {"TRACK", MobFlag::Track},
        {"ILLUSION", MobFlag::Illusion},
        {"POISON_BITE", MobFlag::PoisonBite},
        {"THIEF", MobFlag::Thief},
        {"WARRIOR", MobFlag::Warrior},
        {"SORCERER", MobFlag::Sorcerer},
        {"CLERIC", MobFlag::Cleric},
        {"PALADIN", MobFlag::Paladin},
        {"ANTI_PALADIN", MobFlag::AntiPaladin},
        {"RANGER", MobFlag::Ranger},
        {"DRUID", MobFlag::Druid},
        {"SHAMAN", MobFlag::Shaman},
        {"ASSASSIN", MobFlag::Assassin},
        {"MERCENARY", MobFlag::Mercenary},
        {"NECROMANCER", MobFlag::Necromancer},
        {"CONJURER", MobFlag::Conjurer},
        {"MONK", MobFlag::Monk},
        {"BERSERKER", MobFlag::Berserker},
        {"DIABOLIST", MobFlag::Diabolist},
        {"SLOW_TRACK", MobFlag::SlowTrack},
        {"NO_SILENCE", MobFlag::NoSilence},
        {"PEACEFUL", MobFlag::Peaceful},
        {"PROTECTOR", MobFlag::Protector},
        {"PEACEKEEPER", MobFlag::Peacekeeper},
        {"HASTE", MobFlag::Haste},
        {"BLUR", MobFlag::Blur},
        {"TEACHER", MobFlag::Teacher},
        {"MOUNTABLE", MobFlag::Mountable},
        {"NO_VICIOUS", MobFlag::NoVicious},
        {"NO_CLASS_AI", MobFlag::NoClassAi},
        {"FAST_TRACK", MobFlag::FastTrack},
        {"AQUATIC", MobFlag::Aquatic},
        {"NO_EQ_RESTRICT", MobFlag::NoEqRestrict},
        {"SUMMONED_MOUNT", MobFlag::SummonedMount},
        {"NO_POISON", MobFlag::NoPoison},
        {"BANKER", MobFlag::Banker},
        {"RECEPTIONIST", MobFlag::Receptionist},
        {"POSTMASTER", MobFlag::Postmaster},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobFlag enum to database string */
inline std::string_view mob_flag_to_db(MobFlag e) {
    switch (e) {
        case MobFlag::Spec: return "SPEC";
        case MobFlag::Sentinel: return "SENTINEL";
        case MobFlag::Scavenger: return "SCAVENGER";
        case MobFlag::IsNpc: return "IS_NPC";
        case MobFlag::Aware: return "AWARE";
        case MobFlag::Aggressive: return "AGGRESSIVE";
        case MobFlag::StayZone: return "STAY_ZONE";
        case MobFlag::Wimpy: return "WIMPY";
        case MobFlag::AggroEvil: return "AGGRO_EVIL";
        case MobFlag::AggroGood: return "AGGRO_GOOD";
        case MobFlag::AggroNeutral: return "AGGRO_NEUTRAL";
        case MobFlag::Memory: return "MEMORY";
        case MobFlag::Helper: return "HELPER";
        case MobFlag::NoCharm: return "NO_CHARM";
        case MobFlag::NoSummon: return "NO_SUMMON";
        case MobFlag::NoSleep: return "NO_SLEEP";
        case MobFlag::NoBash: return "NO_BASH";
        case MobFlag::NoBlind: return "NO_BLIND";
        case MobFlag::Mount: return "MOUNT";
        case MobFlag::StaySect: return "STAY_SECT";
        case MobFlag::HatesSun: return "HATES_SUN";
        case MobFlag::NoKill: return "NO_KILL";
        case MobFlag::Track: return "TRACK";
        case MobFlag::Illusion: return "ILLUSION";
        case MobFlag::PoisonBite: return "POISON_BITE";
        case MobFlag::Thief: return "THIEF";
        case MobFlag::Warrior: return "WARRIOR";
        case MobFlag::Sorcerer: return "SORCERER";
        case MobFlag::Cleric: return "CLERIC";
        case MobFlag::Paladin: return "PALADIN";
        case MobFlag::AntiPaladin: return "ANTI_PALADIN";
        case MobFlag::Ranger: return "RANGER";
        case MobFlag::Druid: return "DRUID";
        case MobFlag::Shaman: return "SHAMAN";
        case MobFlag::Assassin: return "ASSASSIN";
        case MobFlag::Mercenary: return "MERCENARY";
        case MobFlag::Necromancer: return "NECROMANCER";
        case MobFlag::Conjurer: return "CONJURER";
        case MobFlag::Monk: return "MONK";
        case MobFlag::Berserker: return "BERSERKER";
        case MobFlag::Diabolist: return "DIABOLIST";
        case MobFlag::SlowTrack: return "SLOW_TRACK";
        case MobFlag::NoSilence: return "NO_SILENCE";
        case MobFlag::Peaceful: return "PEACEFUL";
        case MobFlag::Protector: return "PROTECTOR";
        case MobFlag::Peacekeeper: return "PEACEKEEPER";
        case MobFlag::Haste: return "HASTE";
        case MobFlag::Blur: return "BLUR";
        case MobFlag::Teacher: return "TEACHER";
        case MobFlag::Mountable: return "MOUNTABLE";
        case MobFlag::NoVicious: return "NO_VICIOUS";
        case MobFlag::NoClassAi: return "NO_CLASS_AI";
        case MobFlag::FastTrack: return "FAST_TRACK";
        case MobFlag::Aquatic: return "AQUATIC";
        case MobFlag::NoEqRestrict: return "NO_EQ_RESTRICT";
        case MobFlag::SummonedMount: return "SUMMONED_MOUNT";
        case MobFlag::NoPoison: return "NO_POISON";
        case MobFlag::Banker: return "BANKER";
        case MobFlag::Receptionist: return "RECEPTIONIST";
        case MobFlag::Postmaster: return "POSTMASTER";
    }
    return "";
}

enum class MobRole {
    Trash = 0,
    Normal = 1,
    Elite = 2,
    Miniboss = 3,
    Boss = 4,
    RaidBoss = 5,
};

/** Convert database string to MobRole enum */
inline std::optional<MobRole> mob_role_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, MobRole> lookup = {
        {"TRASH", MobRole::Trash},
        {"NORMAL", MobRole::Normal},
        {"ELITE", MobRole::Elite},
        {"MINIBOSS", MobRole::Miniboss},
        {"BOSS", MobRole::Boss},
        {"RAID_BOSS", MobRole::RaidBoss},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert MobRole enum to database string */
inline std::string_view mob_role_to_db(MobRole e) {
    switch (e) {
        case MobRole::Trash: return "TRASH";
        case MobRole::Normal: return "NORMAL";
        case MobRole::Elite: return "ELITE";
        case MobRole::Miniboss: return "MINIBOSS";
        case MobRole::Boss: return "BOSS";
        case MobRole::RaidBoss: return "RAID_BOSS";
    }
    return "";
}

enum class Position {
    Dead = 0,
    Ghost = 1,
    MortallyWounded = 2,
    Incapacitated = 3,
    Stunned = 4,
    Sleeping = 5,
    Resting = 6,
    Sitting = 7,
    Kneeling = 8,
    Prone = 9,
    Fighting = 10,
    Standing = 11,
    Flying = 12,
};

/** Convert database string to Position enum */
inline std::optional<Position> position_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Position> lookup = {
        {"DEAD", Position::Dead},
        {"GHOST", Position::Ghost},
        {"MORTALLY_WOUNDED", Position::MortallyWounded},
        {"INCAPACITATED", Position::Incapacitated},
        {"STUNNED", Position::Stunned},
        {"SLEEPING", Position::Sleeping},
        {"RESTING", Position::Resting},
        {"SITTING", Position::Sitting},
        {"KNEELING", Position::Kneeling},
        {"PRONE", Position::Prone},
        {"FIGHTING", Position::Fighting},
        {"STANDING", Position::Standing},
        {"FLYING", Position::Flying},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Position enum to database string */
inline std::string_view position_to_db(Position e) {
    switch (e) {
        case Position::Dead: return "DEAD";
        case Position::Ghost: return "GHOST";
        case Position::MortallyWounded: return "MORTALLY_WOUNDED";
        case Position::Incapacitated: return "INCAPACITATED";
        case Position::Stunned: return "STUNNED";
        case Position::Sleeping: return "SLEEPING";
        case Position::Resting: return "RESTING";
        case Position::Sitting: return "SITTING";
        case Position::Kneeling: return "KNEELING";
        case Position::Prone: return "PRONE";
        case Position::Fighting: return "FIGHTING";
        case Position::Standing: return "STANDING";
        case Position::Flying: return "FLYING";
    }
    return "";
}

enum class Stance {
    Dead = 0,
    Mort = 1,
    Incapacitated = 2,
    Stunned = 3,
    Sleeping = 4,
    Resting = 5,
    Alert = 6,
    Fighting = 7,
};

/** Convert database string to Stance enum */
inline std::optional<Stance> stance_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Stance> lookup = {
        {"DEAD", Stance::Dead},
        {"MORT", Stance::Mort},
        {"INCAPACITATED", Stance::Incapacitated},
        {"STUNNED", Stance::Stunned},
        {"SLEEPING", Stance::Sleeping},
        {"RESTING", Stance::Resting},
        {"ALERT", Stance::Alert},
        {"FIGHTING", Stance::Fighting},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Stance enum to database string */
inline std::string_view stance_to_db(Stance e) {
    switch (e) {
        case Stance::Dead: return "DEAD";
        case Stance::Mort: return "MORT";
        case Stance::Incapacitated: return "INCAPACITATED";
        case Stance::Stunned: return "STUNNED";
        case Stance::Sleeping: return "SLEEPING";
        case Stance::Resting: return "RESTING";
        case Stance::Alert: return "ALERT";
        case Stance::Fighting: return "FIGHTING";
    }
    return "";
}

enum class Gender {
    Neutral = 0,
    Male = 1,
    Female = 2,
    NonBinary = 3,
};

/** Convert database string to Gender enum */
inline std::optional<Gender> gender_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Gender> lookup = {
        {"NEUTRAL", Gender::Neutral},
        {"MALE", Gender::Male},
        {"FEMALE", Gender::Female},
        {"NON_BINARY", Gender::NonBinary},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Gender enum to database string */
inline std::string_view gender_to_db(Gender e) {
    switch (e) {
        case Gender::Neutral: return "NEUTRAL";
        case Gender::Male: return "MALE";
        case Gender::Female: return "FEMALE";
        case Gender::NonBinary: return "NON_BINARY";
    }
    return "";
}

enum class Size {
    Tiny = 0,
    Small = 1,
    Medium = 2,
    Large = 3,
    Huge = 4,
    Giant = 5,
    Gargantuan = 6,
    Colossal = 7,
    Titanic = 8,
    Mountainous = 9,
};

/** Convert database string to Size enum */
inline std::optional<Size> size_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Size> lookup = {
        {"TINY", Size::Tiny},
        {"SMALL", Size::Small},
        {"MEDIUM", Size::Medium},
        {"LARGE", Size::Large},
        {"HUGE", Size::Huge},
        {"GIANT", Size::Giant},
        {"GARGANTUAN", Size::Gargantuan},
        {"COLOSSAL", Size::Colossal},
        {"TITANIC", Size::Titanic},
        {"MOUNTAINOUS", Size::Mountainous},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Size enum to database string */
inline std::string_view size_to_db(Size e) {
    switch (e) {
        case Size::Tiny: return "TINY";
        case Size::Small: return "SMALL";
        case Size::Medium: return "MEDIUM";
        case Size::Large: return "LARGE";
        case Size::Huge: return "HUGE";
        case Size::Giant: return "GIANT";
        case Size::Gargantuan: return "GARGANTUAN";
        case Size::Colossal: return "COLOSSAL";
        case Size::Titanic: return "TITANIC";
        case Size::Mountainous: return "MOUNTAINOUS";
    }
    return "";
}

enum class LifeForce {
    Life = 0,
    Undead = 1,
    Magic = 2,
    Celestial = 3,
    Demonic = 4,
    Elemental = 5,
};

/** Convert database string to LifeForce enum */
inline std::optional<LifeForce> life_force_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, LifeForce> lookup = {
        {"LIFE", LifeForce::Life},
        {"UNDEAD", LifeForce::Undead},
        {"MAGIC", LifeForce::Magic},
        {"CELESTIAL", LifeForce::Celestial},
        {"DEMONIC", LifeForce::Demonic},
        {"ELEMENTAL", LifeForce::Elemental},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert LifeForce enum to database string */
inline std::string_view life_force_to_db(LifeForce e) {
    switch (e) {
        case LifeForce::Life: return "LIFE";
        case LifeForce::Undead: return "UNDEAD";
        case LifeForce::Magic: return "MAGIC";
        case LifeForce::Celestial: return "CELESTIAL";
        case LifeForce::Demonic: return "DEMONIC";
        case LifeForce::Elemental: return "ELEMENTAL";
    }
    return "";
}

enum class Composition {
    Flesh = 0,
    Earth = 1,
    Air = 2,
    Fire = 3,
    Water = 4,
    Ice = 5,
    Mist = 6,
    Ether = 7,
    Metal = 8,
    Stone = 9,
    Bone = 10,
    Lava = 11,
    Plant = 12,
};

/** Convert database string to Composition enum */
inline std::optional<Composition> composition_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Composition> lookup = {
        {"FLESH", Composition::Flesh},
        {"EARTH", Composition::Earth},
        {"AIR", Composition::Air},
        {"FIRE", Composition::Fire},
        {"WATER", Composition::Water},
        {"ICE", Composition::Ice},
        {"MIST", Composition::Mist},
        {"ETHER", Composition::Ether},
        {"METAL", Composition::Metal},
        {"STONE", Composition::Stone},
        {"BONE", Composition::Bone},
        {"LAVA", Composition::Lava},
        {"PLANT", Composition::Plant},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Composition enum to database string */
inline std::string_view composition_to_db(Composition e) {
    switch (e) {
        case Composition::Flesh: return "FLESH";
        case Composition::Earth: return "EARTH";
        case Composition::Air: return "AIR";
        case Composition::Fire: return "FIRE";
        case Composition::Water: return "WATER";
        case Composition::Ice: return "ICE";
        case Composition::Mist: return "MIST";
        case Composition::Ether: return "ETHER";
        case Composition::Metal: return "METAL";
        case Composition::Stone: return "STONE";
        case Composition::Bone: return "BONE";
        case Composition::Lava: return "LAVA";
        case Composition::Plant: return "PLANT";
    }
    return "";
}

enum class DamageType {
    Hit = 0,
    Sting = 1,
    Whip = 2,
    Slash = 3,
    Bite = 4,
    Bludgeon = 5,
    Crush = 6,
    Pound = 7,
    Claw = 8,
    Maul = 9,
    Thrash = 10,
    Pierce = 11,
    Blast = 12,
    Punch = 13,
    Stab = 14,
    Fire = 15,
    Cold = 16,
    Acid = 17,
    Shock = 18,
    Poison = 19,
    Align = 20,
    Mental = 21,
    Rot = 22,
    Energy = 23,
    Water = 24,
};

/** Convert database string to DamageType enum */
inline std::optional<DamageType> damage_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, DamageType> lookup = {
        {"HIT", DamageType::Hit},
        {"STING", DamageType::Sting},
        {"WHIP", DamageType::Whip},
        {"SLASH", DamageType::Slash},
        {"BITE", DamageType::Bite},
        {"BLUDGEON", DamageType::Bludgeon},
        {"CRUSH", DamageType::Crush},
        {"POUND", DamageType::Pound},
        {"CLAW", DamageType::Claw},
        {"MAUL", DamageType::Maul},
        {"THRASH", DamageType::Thrash},
        {"PIERCE", DamageType::Pierce},
        {"BLAST", DamageType::Blast},
        {"PUNCH", DamageType::Punch},
        {"STAB", DamageType::Stab},
        {"FIRE", DamageType::Fire},
        {"COLD", DamageType::Cold},
        {"ACID", DamageType::Acid},
        {"SHOCK", DamageType::Shock},
        {"POISON", DamageType::Poison},
        {"ALIGN", DamageType::Align},
        {"MENTAL", DamageType::Mental},
        {"ROT", DamageType::Rot},
        {"ENERGY", DamageType::Energy},
        {"WATER", DamageType::Water},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert DamageType enum to database string */
inline std::string_view damage_type_to_db(DamageType e) {
    switch (e) {
        case DamageType::Hit: return "HIT";
        case DamageType::Sting: return "STING";
        case DamageType::Whip: return "WHIP";
        case DamageType::Slash: return "SLASH";
        case DamageType::Bite: return "BITE";
        case DamageType::Bludgeon: return "BLUDGEON";
        case DamageType::Crush: return "CRUSH";
        case DamageType::Pound: return "POUND";
        case DamageType::Claw: return "CLAW";
        case DamageType::Maul: return "MAUL";
        case DamageType::Thrash: return "THRASH";
        case DamageType::Pierce: return "PIERCE";
        case DamageType::Blast: return "BLAST";
        case DamageType::Punch: return "PUNCH";
        case DamageType::Stab: return "STAB";
        case DamageType::Fire: return "FIRE";
        case DamageType::Cold: return "COLD";
        case DamageType::Acid: return "ACID";
        case DamageType::Shock: return "SHOCK";
        case DamageType::Poison: return "POISON";
        case DamageType::Align: return "ALIGN";
        case DamageType::Mental: return "MENTAL";
        case DamageType::Rot: return "ROT";
        case DamageType::Energy: return "ENERGY";
        case DamageType::Water: return "WATER";
    }
    return "";
}

// ============================================================================
// Object System
// ============================================================================

enum class ObjectType {
    Nothing = 0,
    Light = 1,
    Scroll = 2,
    Wand = 3,
    Staff = 4,
    Weapon = 5,
    Fireweapon = 6,
    Missile = 7,
    Treasure = 8,
    Armor = 9,
    Potion = 10,
    Worn = 11,
    Other = 12,
    Trash = 13,
    Trap = 14,
    Container = 15,
    Note = 16,
    Drinkcontainer = 17,
    Key = 18,
    Food = 19,
    Money = 20,
    Pen = 21,
    Boat = 22,
    Fountain = 23,
    Portal = 24,
    Rope = 25,
    Spellbook = 26,
    Wall = 27,
    Touchstone = 28,
    Board = 29,
    Instrument = 30,
};

/** Convert database string to ObjectType enum */
inline std::optional<ObjectType> object_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ObjectType> lookup = {
        {"NOTHING", ObjectType::Nothing},
        {"LIGHT", ObjectType::Light},
        {"SCROLL", ObjectType::Scroll},
        {"WAND", ObjectType::Wand},
        {"STAFF", ObjectType::Staff},
        {"WEAPON", ObjectType::Weapon},
        {"FIREWEAPON", ObjectType::Fireweapon},
        {"MISSILE", ObjectType::Missile},
        {"TREASURE", ObjectType::Treasure},
        {"ARMOR", ObjectType::Armor},
        {"POTION", ObjectType::Potion},
        {"WORN", ObjectType::Worn},
        {"OTHER", ObjectType::Other},
        {"TRASH", ObjectType::Trash},
        {"TRAP", ObjectType::Trap},
        {"CONTAINER", ObjectType::Container},
        {"NOTE", ObjectType::Note},
        {"DRINKCONTAINER", ObjectType::Drinkcontainer},
        {"KEY", ObjectType::Key},
        {"FOOD", ObjectType::Food},
        {"MONEY", ObjectType::Money},
        {"PEN", ObjectType::Pen},
        {"BOAT", ObjectType::Boat},
        {"FOUNTAIN", ObjectType::Fountain},
        {"PORTAL", ObjectType::Portal},
        {"ROPE", ObjectType::Rope},
        {"SPELLBOOK", ObjectType::Spellbook},
        {"WALL", ObjectType::Wall},
        {"TOUCHSTONE", ObjectType::Touchstone},
        {"BOARD", ObjectType::Board},
        {"INSTRUMENT", ObjectType::Instrument},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ObjectType enum to database string */
inline std::string_view object_type_to_db(ObjectType e) {
    switch (e) {
        case ObjectType::Nothing: return "NOTHING";
        case ObjectType::Light: return "LIGHT";
        case ObjectType::Scroll: return "SCROLL";
        case ObjectType::Wand: return "WAND";
        case ObjectType::Staff: return "STAFF";
        case ObjectType::Weapon: return "WEAPON";
        case ObjectType::Fireweapon: return "FIREWEAPON";
        case ObjectType::Missile: return "MISSILE";
        case ObjectType::Treasure: return "TREASURE";
        case ObjectType::Armor: return "ARMOR";
        case ObjectType::Potion: return "POTION";
        case ObjectType::Worn: return "WORN";
        case ObjectType::Other: return "OTHER";
        case ObjectType::Trash: return "TRASH";
        case ObjectType::Trap: return "TRAP";
        case ObjectType::Container: return "CONTAINER";
        case ObjectType::Note: return "NOTE";
        case ObjectType::Drinkcontainer: return "DRINKCONTAINER";
        case ObjectType::Key: return "KEY";
        case ObjectType::Food: return "FOOD";
        case ObjectType::Money: return "MONEY";
        case ObjectType::Pen: return "PEN";
        case ObjectType::Boat: return "BOAT";
        case ObjectType::Fountain: return "FOUNTAIN";
        case ObjectType::Portal: return "PORTAL";
        case ObjectType::Rope: return "ROPE";
        case ObjectType::Spellbook: return "SPELLBOOK";
        case ObjectType::Wall: return "WALL";
        case ObjectType::Touchstone: return "TOUCHSTONE";
        case ObjectType::Board: return "BOARD";
        case ObjectType::Instrument: return "INSTRUMENT";
    }
    return "";
}

enum class ObjectFlag {
    Glow = 0,
    Hum = 1,
    NoRent = 2,
    AntiBerserker = 3,
    NoInvisible = 4,
    Invisible = 5,
    Magic = 6,
    NoDrop = 7,
    Permanent = 8,
    AntiGood = 9,
    AntiEvil = 10,
    AntiNeutral = 11,
    AntiSorcerer = 12,
    AntiCleric = 13,
    AntiRogue = 14,
    AntiWarrior = 15,
    NoSell = 16,
    AntiPaladin = 17,
    AntiAntiPaladin = 18,
    AntiRanger = 19,
    AntiDruid = 20,
    AntiShaman = 21,
    AntiAssassin = 22,
    AntiMercenary = 23,
    AntiNecromancer = 24,
    AntiConjurer = 25,
    NoBurn = 26,
    NoLocate = 27,
    Decomposing = 28,
    Float = 29,
    NoFall = 30,
    WasDisarmed = 31,
    AntiMonk = 32,
    AntiBard = 33,
    Elven = 34,
    Dwarven = 35,
    AntiThief = 36,
    AntiPyromancer = 37,
    AntiCryomancer = 38,
    AntiIllusionist = 39,
    AntiPriest = 40,
    AntiDiabolist = 41,
    AntiTiny = 42,
    AntiSmall = 43,
    AntiMedium = 44,
    AntiLarge = 45,
    AntiHuge = 46,
    AntiGiant = 47,
    AntiGargantuan = 48,
    AntiColossal = 49,
    AntiTitanic = 50,
    AntiMountainous = 51,
    AntiArborean = 52,
};

/** Convert database string to ObjectFlag enum */
inline std::optional<ObjectFlag> object_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ObjectFlag> lookup = {
        {"GLOW", ObjectFlag::Glow},
        {"HUM", ObjectFlag::Hum},
        {"NO_RENT", ObjectFlag::NoRent},
        {"ANTI_BERSERKER", ObjectFlag::AntiBerserker},
        {"NO_INVISIBLE", ObjectFlag::NoInvisible},
        {"INVISIBLE", ObjectFlag::Invisible},
        {"MAGIC", ObjectFlag::Magic},
        {"NO_DROP", ObjectFlag::NoDrop},
        {"PERMANENT", ObjectFlag::Permanent},
        {"ANTI_GOOD", ObjectFlag::AntiGood},
        {"ANTI_EVIL", ObjectFlag::AntiEvil},
        {"ANTI_NEUTRAL", ObjectFlag::AntiNeutral},
        {"ANTI_SORCERER", ObjectFlag::AntiSorcerer},
        {"ANTI_CLERIC", ObjectFlag::AntiCleric},
        {"ANTI_ROGUE", ObjectFlag::AntiRogue},
        {"ANTI_WARRIOR", ObjectFlag::AntiWarrior},
        {"NO_SELL", ObjectFlag::NoSell},
        {"ANTI_PALADIN", ObjectFlag::AntiPaladin},
        {"ANTI_ANTI_PALADIN", ObjectFlag::AntiAntiPaladin},
        {"ANTI_RANGER", ObjectFlag::AntiRanger},
        {"ANTI_DRUID", ObjectFlag::AntiDruid},
        {"ANTI_SHAMAN", ObjectFlag::AntiShaman},
        {"ANTI_ASSASSIN", ObjectFlag::AntiAssassin},
        {"ANTI_MERCENARY", ObjectFlag::AntiMercenary},
        {"ANTI_NECROMANCER", ObjectFlag::AntiNecromancer},
        {"ANTI_CONJURER", ObjectFlag::AntiConjurer},
        {"NO_BURN", ObjectFlag::NoBurn},
        {"NO_LOCATE", ObjectFlag::NoLocate},
        {"DECOMPOSING", ObjectFlag::Decomposing},
        {"FLOAT", ObjectFlag::Float},
        {"NO_FALL", ObjectFlag::NoFall},
        {"WAS_DISARMED", ObjectFlag::WasDisarmed},
        {"ANTI_MONK", ObjectFlag::AntiMonk},
        {"ANTI_BARD", ObjectFlag::AntiBard},
        {"ELVEN", ObjectFlag::Elven},
        {"DWARVEN", ObjectFlag::Dwarven},
        {"ANTI_THIEF", ObjectFlag::AntiThief},
        {"ANTI_PYROMANCER", ObjectFlag::AntiPyromancer},
        {"ANTI_CRYOMANCER", ObjectFlag::AntiCryomancer},
        {"ANTI_ILLUSIONIST", ObjectFlag::AntiIllusionist},
        {"ANTI_PRIEST", ObjectFlag::AntiPriest},
        {"ANTI_DIABOLIST", ObjectFlag::AntiDiabolist},
        {"ANTI_TINY", ObjectFlag::AntiTiny},
        {"ANTI_SMALL", ObjectFlag::AntiSmall},
        {"ANTI_MEDIUM", ObjectFlag::AntiMedium},
        {"ANTI_LARGE", ObjectFlag::AntiLarge},
        {"ANTI_HUGE", ObjectFlag::AntiHuge},
        {"ANTI_GIANT", ObjectFlag::AntiGiant},
        {"ANTI_GARGANTUAN", ObjectFlag::AntiGargantuan},
        {"ANTI_COLOSSAL", ObjectFlag::AntiColossal},
        {"ANTI_TITANIC", ObjectFlag::AntiTitanic},
        {"ANTI_MOUNTAINOUS", ObjectFlag::AntiMountainous},
        {"ANTI_ARBOREAN", ObjectFlag::AntiArborean},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ObjectFlag enum to database string */
inline std::string_view object_flag_to_db(ObjectFlag e) {
    switch (e) {
        case ObjectFlag::Glow: return "GLOW";
        case ObjectFlag::Hum: return "HUM";
        case ObjectFlag::NoRent: return "NO_RENT";
        case ObjectFlag::AntiBerserker: return "ANTI_BERSERKER";
        case ObjectFlag::NoInvisible: return "NO_INVISIBLE";
        case ObjectFlag::Invisible: return "INVISIBLE";
        case ObjectFlag::Magic: return "MAGIC";
        case ObjectFlag::NoDrop: return "NO_DROP";
        case ObjectFlag::Permanent: return "PERMANENT";
        case ObjectFlag::AntiGood: return "ANTI_GOOD";
        case ObjectFlag::AntiEvil: return "ANTI_EVIL";
        case ObjectFlag::AntiNeutral: return "ANTI_NEUTRAL";
        case ObjectFlag::AntiSorcerer: return "ANTI_SORCERER";
        case ObjectFlag::AntiCleric: return "ANTI_CLERIC";
        case ObjectFlag::AntiRogue: return "ANTI_ROGUE";
        case ObjectFlag::AntiWarrior: return "ANTI_WARRIOR";
        case ObjectFlag::NoSell: return "NO_SELL";
        case ObjectFlag::AntiPaladin: return "ANTI_PALADIN";
        case ObjectFlag::AntiAntiPaladin: return "ANTI_ANTI_PALADIN";
        case ObjectFlag::AntiRanger: return "ANTI_RANGER";
        case ObjectFlag::AntiDruid: return "ANTI_DRUID";
        case ObjectFlag::AntiShaman: return "ANTI_SHAMAN";
        case ObjectFlag::AntiAssassin: return "ANTI_ASSASSIN";
        case ObjectFlag::AntiMercenary: return "ANTI_MERCENARY";
        case ObjectFlag::AntiNecromancer: return "ANTI_NECROMANCER";
        case ObjectFlag::AntiConjurer: return "ANTI_CONJURER";
        case ObjectFlag::NoBurn: return "NO_BURN";
        case ObjectFlag::NoLocate: return "NO_LOCATE";
        case ObjectFlag::Decomposing: return "DECOMPOSING";
        case ObjectFlag::Float: return "FLOAT";
        case ObjectFlag::NoFall: return "NO_FALL";
        case ObjectFlag::WasDisarmed: return "WAS_DISARMED";
        case ObjectFlag::AntiMonk: return "ANTI_MONK";
        case ObjectFlag::AntiBard: return "ANTI_BARD";
        case ObjectFlag::Elven: return "ELVEN";
        case ObjectFlag::Dwarven: return "DWARVEN";
        case ObjectFlag::AntiThief: return "ANTI_THIEF";
        case ObjectFlag::AntiPyromancer: return "ANTI_PYROMANCER";
        case ObjectFlag::AntiCryomancer: return "ANTI_CRYOMANCER";
        case ObjectFlag::AntiIllusionist: return "ANTI_ILLUSIONIST";
        case ObjectFlag::AntiPriest: return "ANTI_PRIEST";
        case ObjectFlag::AntiDiabolist: return "ANTI_DIABOLIST";
        case ObjectFlag::AntiTiny: return "ANTI_TINY";
        case ObjectFlag::AntiSmall: return "ANTI_SMALL";
        case ObjectFlag::AntiMedium: return "ANTI_MEDIUM";
        case ObjectFlag::AntiLarge: return "ANTI_LARGE";
        case ObjectFlag::AntiHuge: return "ANTI_HUGE";
        case ObjectFlag::AntiGiant: return "ANTI_GIANT";
        case ObjectFlag::AntiGargantuan: return "ANTI_GARGANTUAN";
        case ObjectFlag::AntiColossal: return "ANTI_COLOSSAL";
        case ObjectFlag::AntiTitanic: return "ANTI_TITANIC";
        case ObjectFlag::AntiMountainous: return "ANTI_MOUNTAINOUS";
        case ObjectFlag::AntiArborean: return "ANTI_ARBOREAN";
    }
    return "";
}

enum class WearFlag {
    Take = 0,
    Finger = 1,
    Neck = 2,
    Body = 3,
    Head = 4,
    Legs = 5,
    Feet = 6,
    Hands = 7,
    Arms = 8,
    Shield = 9,
    About = 10,
    Waist = 11,
    Wrist = 12,
    Wield = 13,
    Hold = 14,
    TwoHandWield = 15,
    Eyes = 16,
    Face = 17,
    Ear = 18,
    Badge = 19,
    Belt = 20,
    Hover = 21,
};

/** Convert database string to WearFlag enum */
inline std::optional<WearFlag> wear_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, WearFlag> lookup = {
        {"TAKE", WearFlag::Take},
        {"FINGER", WearFlag::Finger},
        {"NECK", WearFlag::Neck},
        {"BODY", WearFlag::Body},
        {"HEAD", WearFlag::Head},
        {"LEGS", WearFlag::Legs},
        {"FEET", WearFlag::Feet},
        {"HANDS", WearFlag::Hands},
        {"ARMS", WearFlag::Arms},
        {"SHIELD", WearFlag::Shield},
        {"ABOUT", WearFlag::About},
        {"WAIST", WearFlag::Waist},
        {"WRIST", WearFlag::Wrist},
        {"WIELD", WearFlag::Wield},
        {"HOLD", WearFlag::Hold},
        {"TWO_HAND_WIELD", WearFlag::TwoHandWield},
        {"EYES", WearFlag::Eyes},
        {"FACE", WearFlag::Face},
        {"EAR", WearFlag::Ear},
        {"BADGE", WearFlag::Badge},
        {"BELT", WearFlag::Belt},
        {"HOVER", WearFlag::Hover},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert WearFlag enum to database string */
inline std::string_view wear_flag_to_db(WearFlag e) {
    switch (e) {
        case WearFlag::Take: return "TAKE";
        case WearFlag::Finger: return "FINGER";
        case WearFlag::Neck: return "NECK";
        case WearFlag::Body: return "BODY";
        case WearFlag::Head: return "HEAD";
        case WearFlag::Legs: return "LEGS";
        case WearFlag::Feet: return "FEET";
        case WearFlag::Hands: return "HANDS";
        case WearFlag::Arms: return "ARMS";
        case WearFlag::Shield: return "SHIELD";
        case WearFlag::About: return "ABOUT";
        case WearFlag::Waist: return "WAIST";
        case WearFlag::Wrist: return "WRIST";
        case WearFlag::Wield: return "WIELD";
        case WearFlag::Hold: return "HOLD";
        case WearFlag::TwoHandWield: return "TWO_HAND_WIELD";
        case WearFlag::Eyes: return "EYES";
        case WearFlag::Face: return "FACE";
        case WearFlag::Ear: return "EAR";
        case WearFlag::Badge: return "BADGE";
        case WearFlag::Belt: return "BELT";
        case WearFlag::Hover: return "HOVER";
    }
    return "";
}

// ============================================================================
// Effect System
// ============================================================================

enum class EffectFlag {
    Blind = 0,
    Invisible = 1,
    DetectAlign = 2,
    DetectInvis = 3,
    DetectMagic = 4,
    SenseLife = 5,
    Waterwalk = 6,
    Sanctuary = 7,
    Confusion = 8,
    Curse = 9,
    Infravision = 10,
    Poison = 11,
    ProtectEvil = 12,
    ProtectGood = 13,
    Sleep = 14,
    NoTrack = 15,
    Tamed = 16,
    Berserk = 17,
    Sneak = 18,
    Stealth = 19,
    Fly = 20,
    Charm = 21,
    StoneSkin = 22,
    Farsee = 23,
    Haste = 24,
    Blur = 25,
    Vitality = 26,
    Glory = 27,
    MajorParalysis = 28,
    Familiarity = 29,
    Mesmerized = 30,
    Immobilized = 31,
    Light = 32,
    Unused = 33,
    MinorParalysis = 34,
    HurtThroat = 35,
    FeatherFall = 36,
    Waterbreath = 37,
    Soulshield = 38,
    Silence = 39,
    ProtectFire = 40,
    ProtectCold = 41,
    ProtectAir = 42,
    ProtectEarth = 43,
    Fireshield = 44,
    Coldshield = 45,
    MinorGlobe = 46,
    MajorGlobe = 47,
    Harness = 48,
    OnFire = 49,
    Fear = 50,
    Tongues = 51,
    Disease = 52,
    Insanity = 53,
    Ultravision = 54,
    NegateHeat = 55,
    NegateCold = 56,
    NegateAir = 57,
    NegateEarth = 58,
    RemoteAggro = 59,
    Aware = 60,
    Reduce = 61,
    Enlarge = 62,
    VampiricTouch = 63,
    RayOfEnfeeblement = 64,
    Animated = 65,
    Exposed = 66,
    Shadowing = 67,
    Camouflaged = 68,
    SpiritWolf = 69,
    SpiritBear = 70,
    Wrath = 71,
    Misdirection = 72,
    Misdirecting = 73,
    Bless = 74,
    Hex = 75,
    DetectPoison = 76,
    SongOfRest = 77,
    Displacement = 78,
    GreaterDisplacement = 79,
    FireWeapon = 80,
    IceWeapon = 81,
    PoisonWeapon = 82,
    AcidWeapon = 83,
    ShockWeapon = 84,
    RadiantWeapon = 85,
};

/** Convert database string to EffectFlag enum */
inline std::optional<EffectFlag> effect_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, EffectFlag> lookup = {
        {"BLIND", EffectFlag::Blind},
        {"INVISIBLE", EffectFlag::Invisible},
        {"DETECT_ALIGN", EffectFlag::DetectAlign},
        {"DETECT_INVIS", EffectFlag::DetectInvis},
        {"DETECT_MAGIC", EffectFlag::DetectMagic},
        {"SENSE_LIFE", EffectFlag::SenseLife},
        {"WATERWALK", EffectFlag::Waterwalk},
        {"SANCTUARY", EffectFlag::Sanctuary},
        {"CONFUSION", EffectFlag::Confusion},
        {"CURSE", EffectFlag::Curse},
        {"INFRAVISION", EffectFlag::Infravision},
        {"POISON", EffectFlag::Poison},
        {"PROTECT_EVIL", EffectFlag::ProtectEvil},
        {"PROTECT_GOOD", EffectFlag::ProtectGood},
        {"SLEEP", EffectFlag::Sleep},
        {"NO_TRACK", EffectFlag::NoTrack},
        {"TAMED", EffectFlag::Tamed},
        {"BERSERK", EffectFlag::Berserk},
        {"SNEAK", EffectFlag::Sneak},
        {"STEALTH", EffectFlag::Stealth},
        {"FLY", EffectFlag::Fly},
        {"CHARM", EffectFlag::Charm},
        {"STONE_SKIN", EffectFlag::StoneSkin},
        {"FARSEE", EffectFlag::Farsee},
        {"HASTE", EffectFlag::Haste},
        {"BLUR", EffectFlag::Blur},
        {"VITALITY", EffectFlag::Vitality},
        {"GLORY", EffectFlag::Glory},
        {"MAJOR_PARALYSIS", EffectFlag::MajorParalysis},
        {"FAMILIARITY", EffectFlag::Familiarity},
        {"MESMERIZED", EffectFlag::Mesmerized},
        {"IMMOBILIZED", EffectFlag::Immobilized},
        {"LIGHT", EffectFlag::Light},
        {"UNUSED", EffectFlag::Unused},
        {"MINOR_PARALYSIS", EffectFlag::MinorParalysis},
        {"HURT_THROAT", EffectFlag::HurtThroat},
        {"FEATHER_FALL", EffectFlag::FeatherFall},
        {"WATERBREATH", EffectFlag::Waterbreath},
        {"SOULSHIELD", EffectFlag::Soulshield},
        {"SILENCE", EffectFlag::Silence},
        {"PROTECT_FIRE", EffectFlag::ProtectFire},
        {"PROTECT_COLD", EffectFlag::ProtectCold},
        {"PROTECT_AIR", EffectFlag::ProtectAir},
        {"PROTECT_EARTH", EffectFlag::ProtectEarth},
        {"FIRESHIELD", EffectFlag::Fireshield},
        {"COLDSHIELD", EffectFlag::Coldshield},
        {"MINOR_GLOBE", EffectFlag::MinorGlobe},
        {"MAJOR_GLOBE", EffectFlag::MajorGlobe},
        {"HARNESS", EffectFlag::Harness},
        {"ON_FIRE", EffectFlag::OnFire},
        {"FEAR", EffectFlag::Fear},
        {"TONGUES", EffectFlag::Tongues},
        {"DISEASE", EffectFlag::Disease},
        {"INSANITY", EffectFlag::Insanity},
        {"ULTRAVISION", EffectFlag::Ultravision},
        {"NEGATE_HEAT", EffectFlag::NegateHeat},
        {"NEGATE_COLD", EffectFlag::NegateCold},
        {"NEGATE_AIR", EffectFlag::NegateAir},
        {"NEGATE_EARTH", EffectFlag::NegateEarth},
        {"REMOTE_AGGRO", EffectFlag::RemoteAggro},
        {"AWARE", EffectFlag::Aware},
        {"REDUCE", EffectFlag::Reduce},
        {"ENLARGE", EffectFlag::Enlarge},
        {"VAMPIRIC_TOUCH", EffectFlag::VampiricTouch},
        {"RAY_OF_ENFEEBLEMENT", EffectFlag::RayOfEnfeeblement},
        {"ANIMATED", EffectFlag::Animated},
        {"EXPOSED", EffectFlag::Exposed},
        {"SHADOWING", EffectFlag::Shadowing},
        {"CAMOUFLAGED", EffectFlag::Camouflaged},
        {"SPIRIT_WOLF", EffectFlag::SpiritWolf},
        {"SPIRIT_BEAR", EffectFlag::SpiritBear},
        {"WRATH", EffectFlag::Wrath},
        {"MISDIRECTION", EffectFlag::Misdirection},
        {"MISDIRECTING", EffectFlag::Misdirecting},
        {"BLESS", EffectFlag::Bless},
        {"HEX", EffectFlag::Hex},
        {"DETECT_POISON", EffectFlag::DetectPoison},
        {"SONG_OF_REST", EffectFlag::SongOfRest},
        {"DISPLACEMENT", EffectFlag::Displacement},
        {"GREATER_DISPLACEMENT", EffectFlag::GreaterDisplacement},
        {"FIRE_WEAPON", EffectFlag::FireWeapon},
        {"ICE_WEAPON", EffectFlag::IceWeapon},
        {"POISON_WEAPON", EffectFlag::PoisonWeapon},
        {"ACID_WEAPON", EffectFlag::AcidWeapon},
        {"SHOCK_WEAPON", EffectFlag::ShockWeapon},
        {"RADIANT_WEAPON", EffectFlag::RadiantWeapon},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert EffectFlag enum to database string */
inline std::string_view effect_flag_to_db(EffectFlag e) {
    switch (e) {
        case EffectFlag::Blind: return "BLIND";
        case EffectFlag::Invisible: return "INVISIBLE";
        case EffectFlag::DetectAlign: return "DETECT_ALIGN";
        case EffectFlag::DetectInvis: return "DETECT_INVIS";
        case EffectFlag::DetectMagic: return "DETECT_MAGIC";
        case EffectFlag::SenseLife: return "SENSE_LIFE";
        case EffectFlag::Waterwalk: return "WATERWALK";
        case EffectFlag::Sanctuary: return "SANCTUARY";
        case EffectFlag::Confusion: return "CONFUSION";
        case EffectFlag::Curse: return "CURSE";
        case EffectFlag::Infravision: return "INFRAVISION";
        case EffectFlag::Poison: return "POISON";
        case EffectFlag::ProtectEvil: return "PROTECT_EVIL";
        case EffectFlag::ProtectGood: return "PROTECT_GOOD";
        case EffectFlag::Sleep: return "SLEEP";
        case EffectFlag::NoTrack: return "NO_TRACK";
        case EffectFlag::Tamed: return "TAMED";
        case EffectFlag::Berserk: return "BERSERK";
        case EffectFlag::Sneak: return "SNEAK";
        case EffectFlag::Stealth: return "STEALTH";
        case EffectFlag::Fly: return "FLY";
        case EffectFlag::Charm: return "CHARM";
        case EffectFlag::StoneSkin: return "STONE_SKIN";
        case EffectFlag::Farsee: return "FARSEE";
        case EffectFlag::Haste: return "HASTE";
        case EffectFlag::Blur: return "BLUR";
        case EffectFlag::Vitality: return "VITALITY";
        case EffectFlag::Glory: return "GLORY";
        case EffectFlag::MajorParalysis: return "MAJOR_PARALYSIS";
        case EffectFlag::Familiarity: return "FAMILIARITY";
        case EffectFlag::Mesmerized: return "MESMERIZED";
        case EffectFlag::Immobilized: return "IMMOBILIZED";
        case EffectFlag::Light: return "LIGHT";
        case EffectFlag::Unused: return "UNUSED";
        case EffectFlag::MinorParalysis: return "MINOR_PARALYSIS";
        case EffectFlag::HurtThroat: return "HURT_THROAT";
        case EffectFlag::FeatherFall: return "FEATHER_FALL";
        case EffectFlag::Waterbreath: return "WATERBREATH";
        case EffectFlag::Soulshield: return "SOULSHIELD";
        case EffectFlag::Silence: return "SILENCE";
        case EffectFlag::ProtectFire: return "PROTECT_FIRE";
        case EffectFlag::ProtectCold: return "PROTECT_COLD";
        case EffectFlag::ProtectAir: return "PROTECT_AIR";
        case EffectFlag::ProtectEarth: return "PROTECT_EARTH";
        case EffectFlag::Fireshield: return "FIRESHIELD";
        case EffectFlag::Coldshield: return "COLDSHIELD";
        case EffectFlag::MinorGlobe: return "MINOR_GLOBE";
        case EffectFlag::MajorGlobe: return "MAJOR_GLOBE";
        case EffectFlag::Harness: return "HARNESS";
        case EffectFlag::OnFire: return "ON_FIRE";
        case EffectFlag::Fear: return "FEAR";
        case EffectFlag::Tongues: return "TONGUES";
        case EffectFlag::Disease: return "DISEASE";
        case EffectFlag::Insanity: return "INSANITY";
        case EffectFlag::Ultravision: return "ULTRAVISION";
        case EffectFlag::NegateHeat: return "NEGATE_HEAT";
        case EffectFlag::NegateCold: return "NEGATE_COLD";
        case EffectFlag::NegateAir: return "NEGATE_AIR";
        case EffectFlag::NegateEarth: return "NEGATE_EARTH";
        case EffectFlag::RemoteAggro: return "REMOTE_AGGRO";
        case EffectFlag::Aware: return "AWARE";
        case EffectFlag::Reduce: return "REDUCE";
        case EffectFlag::Enlarge: return "ENLARGE";
        case EffectFlag::VampiricTouch: return "VAMPIRIC_TOUCH";
        case EffectFlag::RayOfEnfeeblement: return "RAY_OF_ENFEEBLEMENT";
        case EffectFlag::Animated: return "ANIMATED";
        case EffectFlag::Exposed: return "EXPOSED";
        case EffectFlag::Shadowing: return "SHADOWING";
        case EffectFlag::Camouflaged: return "CAMOUFLAGED";
        case EffectFlag::SpiritWolf: return "SPIRIT_WOLF";
        case EffectFlag::SpiritBear: return "SPIRIT_BEAR";
        case EffectFlag::Wrath: return "WRATH";
        case EffectFlag::Misdirection: return "MISDIRECTION";
        case EffectFlag::Misdirecting: return "MISDIRECTING";
        case EffectFlag::Bless: return "BLESS";
        case EffectFlag::Hex: return "HEX";
        case EffectFlag::DetectPoison: return "DETECT_POISON";
        case EffectFlag::SongOfRest: return "SONG_OF_REST";
        case EffectFlag::Displacement: return "DISPLACEMENT";
        case EffectFlag::GreaterDisplacement: return "GREATER_DISPLACEMENT";
        case EffectFlag::FireWeapon: return "FIRE_WEAPON";
        case EffectFlag::IceWeapon: return "ICE_WEAPON";
        case EffectFlag::PoisonWeapon: return "POISON_WEAPON";
        case EffectFlag::AcidWeapon: return "ACID_WEAPON";
        case EffectFlag::ShockWeapon: return "SHOCK_WEAPON";
        case EffectFlag::RadiantWeapon: return "RADIANT_WEAPON";
    }
    return "";
}

enum class ElementType {
    Physical = 0,
    Slash = 1,
    Pierce = 2,
    Crush = 3,
    Force = 4,
    Sonic = 5,
    Bleed = 6,
    Fire = 7,
    Cold = 8,
    Water = 9,
    Earth = 10,
    Air = 11,
    Shock = 12,
    Acid = 13,
    Poison = 14,
    Radiant = 15,
    Shadow = 16,
    Holy = 17,
    Unholy = 18,
    Heal = 19,
    Necrotic = 20,
    Mental = 21,
    Nature = 22,
};

/** Convert database string to ElementType enum */
inline std::optional<ElementType> element_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ElementType> lookup = {
        {"PHYSICAL", ElementType::Physical},
        {"SLASH", ElementType::Slash},
        {"PIERCE", ElementType::Pierce},
        {"CRUSH", ElementType::Crush},
        {"FORCE", ElementType::Force},
        {"SONIC", ElementType::Sonic},
        {"BLEED", ElementType::Bleed},
        {"FIRE", ElementType::Fire},
        {"COLD", ElementType::Cold},
        {"WATER", ElementType::Water},
        {"EARTH", ElementType::Earth},
        {"AIR", ElementType::Air},
        {"SHOCK", ElementType::Shock},
        {"ACID", ElementType::Acid},
        {"POISON", ElementType::Poison},
        {"RADIANT", ElementType::Radiant},
        {"SHADOW", ElementType::Shadow},
        {"HOLY", ElementType::Holy},
        {"UNHOLY", ElementType::Unholy},
        {"HEAL", ElementType::Heal},
        {"NECROTIC", ElementType::Necrotic},
        {"MENTAL", ElementType::Mental},
        {"NATURE", ElementType::Nature},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ElementType enum to database string */
inline std::string_view element_type_to_db(ElementType e) {
    switch (e) {
        case ElementType::Physical: return "PHYSICAL";
        case ElementType::Slash: return "SLASH";
        case ElementType::Pierce: return "PIERCE";
        case ElementType::Crush: return "CRUSH";
        case ElementType::Force: return "FORCE";
        case ElementType::Sonic: return "SONIC";
        case ElementType::Bleed: return "BLEED";
        case ElementType::Fire: return "FIRE";
        case ElementType::Cold: return "COLD";
        case ElementType::Water: return "WATER";
        case ElementType::Earth: return "EARTH";
        case ElementType::Air: return "AIR";
        case ElementType::Shock: return "SHOCK";
        case ElementType::Acid: return "ACID";
        case ElementType::Poison: return "POISON";
        case ElementType::Radiant: return "RADIANT";
        case ElementType::Shadow: return "SHADOW";
        case ElementType::Holy: return "HOLY";
        case ElementType::Unholy: return "UNHOLY";
        case ElementType::Heal: return "HEAL";
        case ElementType::Necrotic: return "NECROTIC";
        case ElementType::Mental: return "MENTAL";
        case ElementType::Nature: return "NATURE";
    }
    return "";
}

enum class ApplyType {
    Ac = 0,
    Hitroll = 1,
    Damroll = 2,
    Str = 3,
    Dex = 4,
    Int = 5,
    Wis = 6,
    Con = 7,
    Cha = 8,
    SavingPara = 9,
    SavingRod = 10,
    SavingPetri = 11,
    SavingBreath = 12,
    SavingSpell = 13,
    HitRegen = 14,
    MaxHp = 15,
    MaxMana = 16,
    MaxMovement = 17,
    Perception = 18,
    Hiddenness = 19,
    Size = 20,
    Age = 21,
    CharWeight = 22,
    CharHeight = 23,
    Focus = 24,
    Composition = 25,
    Level = 26,
    None = 27,
};

/** Convert database string to ApplyType enum */
inline std::optional<ApplyType> apply_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ApplyType> lookup = {
        {"AC", ApplyType::Ac},
        {"HITROLL", ApplyType::Hitroll},
        {"DAMROLL", ApplyType::Damroll},
        {"STR", ApplyType::Str},
        {"DEX", ApplyType::Dex},
        {"INT", ApplyType::Int},
        {"WIS", ApplyType::Wis},
        {"CON", ApplyType::Con},
        {"CHA", ApplyType::Cha},
        {"SAVING_PARA", ApplyType::SavingPara},
        {"SAVING_ROD", ApplyType::SavingRod},
        {"SAVING_PETRI", ApplyType::SavingPetri},
        {"SAVING_BREATH", ApplyType::SavingBreath},
        {"SAVING_SPELL", ApplyType::SavingSpell},
        {"HIT_REGEN", ApplyType::HitRegen},
        {"MAX_HP", ApplyType::MaxHp},
        {"MAX_MANA", ApplyType::MaxMana},
        {"MAX_MOVEMENT", ApplyType::MaxMovement},
        {"PERCEPTION", ApplyType::Perception},
        {"HIDDENNESS", ApplyType::Hiddenness},
        {"SIZE", ApplyType::Size},
        {"AGE", ApplyType::Age},
        {"CHAR_WEIGHT", ApplyType::CharWeight},
        {"CHAR_HEIGHT", ApplyType::CharHeight},
        {"FOCUS", ApplyType::Focus},
        {"COMPOSITION", ApplyType::Composition},
        {"LEVEL", ApplyType::Level},
        {"NONE", ApplyType::None},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ApplyType enum to database string */
inline std::string_view apply_type_to_db(ApplyType e) {
    switch (e) {
        case ApplyType::Ac: return "AC";
        case ApplyType::Hitroll: return "HITROLL";
        case ApplyType::Damroll: return "DAMROLL";
        case ApplyType::Str: return "STR";
        case ApplyType::Dex: return "DEX";
        case ApplyType::Int: return "INT";
        case ApplyType::Wis: return "WIS";
        case ApplyType::Con: return "CON";
        case ApplyType::Cha: return "CHA";
        case ApplyType::SavingPara: return "SAVING_PARA";
        case ApplyType::SavingRod: return "SAVING_ROD";
        case ApplyType::SavingPetri: return "SAVING_PETRI";
        case ApplyType::SavingBreath: return "SAVING_BREATH";
        case ApplyType::SavingSpell: return "SAVING_SPELL";
        case ApplyType::HitRegen: return "HIT_REGEN";
        case ApplyType::MaxHp: return "MAX_HP";
        case ApplyType::MaxMana: return "MAX_MANA";
        case ApplyType::MaxMovement: return "MAX_MOVEMENT";
        case ApplyType::Perception: return "PERCEPTION";
        case ApplyType::Hiddenness: return "HIDDENNESS";
        case ApplyType::Size: return "SIZE";
        case ApplyType::Age: return "AGE";
        case ApplyType::CharWeight: return "CHAR_WEIGHT";
        case ApplyType::CharHeight: return "CHAR_HEIGHT";
        case ApplyType::Focus: return "FOCUS";
        case ApplyType::Composition: return "COMPOSITION";
        case ApplyType::Level: return "LEVEL";
        case ApplyType::None: return "NONE";
    }
    return "";
}

// ============================================================================
// Character System
// ============================================================================

enum class Race {
    Human = 0,
    Elf = 1,
    Gnome = 2,
    Dwarf = 3,
    Troll = 4,
    Drow = 5,
    Duergar = 6,
    Ogre = 7,
    Orc = 8,
    HalfElf = 9,
    Barbarian = 10,
    Halfling = 11,
    Plant = 12,
    Humanoid = 13,
    Animal = 14,
    DragonGeneral = 15,
    Giant = 16,
    Other = 17,
    Goblin = 18,
    Demon = 19,
    Brownie = 20,
    DragonFire = 21,
    DragonFrost = 22,
    DragonAcid = 23,
    DragonLightning = 24,
    DragonGas = 25,
    DragonbornFire = 26,
    DragonbornFrost = 27,
    DragonbornAcid = 28,
    DragonbornLightning = 29,
    DragonbornGas = 30,
    Sverfneblin = 31,
    FaerieSeelie = 32,
    FaerieUnseelie = 33,
    Nymph = 34,
    Arborean = 35,
};

/** Convert database string to Race enum */
inline std::optional<Race> race_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Race> lookup = {
        {"HUMAN", Race::Human},
        {"ELF", Race::Elf},
        {"GNOME", Race::Gnome},
        {"DWARF", Race::Dwarf},
        {"TROLL", Race::Troll},
        {"DROW", Race::Drow},
        {"DUERGAR", Race::Duergar},
        {"OGRE", Race::Ogre},
        {"ORC", Race::Orc},
        {"HALF_ELF", Race::HalfElf},
        {"BARBARIAN", Race::Barbarian},
        {"HALFLING", Race::Halfling},
        {"PLANT", Race::Plant},
        {"HUMANOID", Race::Humanoid},
        {"ANIMAL", Race::Animal},
        {"DRAGON_GENERAL", Race::DragonGeneral},
        {"GIANT", Race::Giant},
        {"OTHER", Race::Other},
        {"GOBLIN", Race::Goblin},
        {"DEMON", Race::Demon},
        {"BROWNIE", Race::Brownie},
        {"DRAGON_FIRE", Race::DragonFire},
        {"DRAGON_FROST", Race::DragonFrost},
        {"DRAGON_ACID", Race::DragonAcid},
        {"DRAGON_LIGHTNING", Race::DragonLightning},
        {"DRAGON_GAS", Race::DragonGas},
        {"DRAGONBORN_FIRE", Race::DragonbornFire},
        {"DRAGONBORN_FROST", Race::DragonbornFrost},
        {"DRAGONBORN_ACID", Race::DragonbornAcid},
        {"DRAGONBORN_LIGHTNING", Race::DragonbornLightning},
        {"DRAGONBORN_GAS", Race::DragonbornGas},
        {"SVERFNEBLIN", Race::Sverfneblin},
        {"FAERIE_SEELIE", Race::FaerieSeelie},
        {"FAERIE_UNSEELIE", Race::FaerieUnseelie},
        {"NYMPH", Race::Nymph},
        {"ARBOREAN", Race::Arborean},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Race enum to database string */
inline std::string_view race_to_db(Race e) {
    switch (e) {
        case Race::Human: return "HUMAN";
        case Race::Elf: return "ELF";
        case Race::Gnome: return "GNOME";
        case Race::Dwarf: return "DWARF";
        case Race::Troll: return "TROLL";
        case Race::Drow: return "DROW";
        case Race::Duergar: return "DUERGAR";
        case Race::Ogre: return "OGRE";
        case Race::Orc: return "ORC";
        case Race::HalfElf: return "HALF_ELF";
        case Race::Barbarian: return "BARBARIAN";
        case Race::Halfling: return "HALFLING";
        case Race::Plant: return "PLANT";
        case Race::Humanoid: return "HUMANOID";
        case Race::Animal: return "ANIMAL";
        case Race::DragonGeneral: return "DRAGON_GENERAL";
        case Race::Giant: return "GIANT";
        case Race::Other: return "OTHER";
        case Race::Goblin: return "GOBLIN";
        case Race::Demon: return "DEMON";
        case Race::Brownie: return "BROWNIE";
        case Race::DragonFire: return "DRAGON_FIRE";
        case Race::DragonFrost: return "DRAGON_FROST";
        case Race::DragonAcid: return "DRAGON_ACID";
        case Race::DragonLightning: return "DRAGON_LIGHTNING";
        case Race::DragonGas: return "DRAGON_GAS";
        case Race::DragonbornFire: return "DRAGONBORN_FIRE";
        case Race::DragonbornFrost: return "DRAGONBORN_FROST";
        case Race::DragonbornAcid: return "DRAGONBORN_ACID";
        case Race::DragonbornLightning: return "DRAGONBORN_LIGHTNING";
        case Race::DragonbornGas: return "DRAGONBORN_GAS";
        case Race::Sverfneblin: return "SVERFNEBLIN";
        case Race::FaerieSeelie: return "FAERIE_SEELIE";
        case Race::FaerieUnseelie: return "FAERIE_UNSEELIE";
        case Race::Nymph: return "NYMPH";
        case Race::Arborean: return "ARBOREAN";
    }
    return "";
}

enum class RaceAlign {
    Unknown = 0,
    Good = 1,
    Evil = 2,
};

/** Convert database string to RaceAlign enum */
inline std::optional<RaceAlign> race_align_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, RaceAlign> lookup = {
        {"UNKNOWN", RaceAlign::Unknown},
        {"GOOD", RaceAlign::Good},
        {"EVIL", RaceAlign::Evil},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert RaceAlign enum to database string */
inline std::string_view race_align_to_db(RaceAlign e) {
    switch (e) {
        case RaceAlign::Unknown: return "UNKNOWN";
        case RaceAlign::Good: return "GOOD";
        case RaceAlign::Evil: return "EVIL";
    }
    return "";
}

enum class SkillCategory {
    Primary = 0,
    Secondary = 1,
    Restricted = 2,
    Forbidden = 3,
};

/** Convert database string to SkillCategory enum */
inline std::optional<SkillCategory> skill_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SkillCategory> lookup = {
        {"PRIMARY", SkillCategory::Primary},
        {"SECONDARY", SkillCategory::Secondary},
        {"RESTRICTED", SkillCategory::Restricted},
        {"FORBIDDEN", SkillCategory::Forbidden},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SkillCategory enum to database string */
inline std::string_view skill_category_to_db(SkillCategory e) {
    switch (e) {
        case SkillCategory::Primary: return "PRIMARY";
        case SkillCategory::Secondary: return "SECONDARY";
        case SkillCategory::Restricted: return "RESTRICTED";
        case SkillCategory::Forbidden: return "FORBIDDEN";
    }
    return "";
}

enum class SkillType {
    Weapon = 0,
    Combat = 1,
    Magic = 2,
    Stealth = 3,
    Social = 4,
    Crafting = 5,
    Survival = 6,
    Knowledge = 7,
    Utility = 8,
};

/** Convert database string to SkillType enum */
inline std::optional<SkillType> skill_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SkillType> lookup = {
        {"WEAPON", SkillType::Weapon},
        {"COMBAT", SkillType::Combat},
        {"MAGIC", SkillType::Magic},
        {"STEALTH", SkillType::Stealth},
        {"SOCIAL", SkillType::Social},
        {"CRAFTING", SkillType::Crafting},
        {"SURVIVAL", SkillType::Survival},
        {"KNOWLEDGE", SkillType::Knowledge},
        {"UTILITY", SkillType::Utility},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SkillType enum to database string */
inline std::string_view skill_type_to_db(SkillType e) {
    switch (e) {
        case SkillType::Weapon: return "WEAPON";
        case SkillType::Combat: return "COMBAT";
        case SkillType::Magic: return "MAGIC";
        case SkillType::Stealth: return "STEALTH";
        case SkillType::Social: return "SOCIAL";
        case SkillType::Crafting: return "CRAFTING";
        case SkillType::Survival: return "SURVIVAL";
        case SkillType::Knowledge: return "KNOWLEDGE";
        case SkillType::Utility: return "UTILITY";
    }
    return "";
}

// ============================================================================
// Ability System
// ============================================================================

enum class SpellSphere {
    Generic = 0,
    Fire = 1,
    Water = 2,
    Earth = 3,
    Air = 4,
    Healing = 5,
    Protection = 6,
    Enchantment = 7,
    Summoning = 8,
    Death = 9,
    Divination = 10,
};

/** Convert database string to SpellSphere enum */
inline std::optional<SpellSphere> spell_sphere_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SpellSphere> lookup = {
        {"GENERIC", SpellSphere::Generic},
        {"FIRE", SpellSphere::Fire},
        {"WATER", SpellSphere::Water},
        {"EARTH", SpellSphere::Earth},
        {"AIR", SpellSphere::Air},
        {"HEALING", SpellSphere::Healing},
        {"PROTECTION", SpellSphere::Protection},
        {"ENCHANTMENT", SpellSphere::Enchantment},
        {"SUMMONING", SpellSphere::Summoning},
        {"DEATH", SpellSphere::Death},
        {"DIVINATION", SpellSphere::Divination},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SpellSphere enum to database string */
inline std::string_view spell_sphere_to_db(SpellSphere e) {
    switch (e) {
        case SpellSphere::Generic: return "GENERIC";
        case SpellSphere::Fire: return "FIRE";
        case SpellSphere::Water: return "WATER";
        case SpellSphere::Earth: return "EARTH";
        case SpellSphere::Air: return "AIR";
        case SpellSphere::Healing: return "HEALING";
        case SpellSphere::Protection: return "PROTECTION";
        case SpellSphere::Enchantment: return "ENCHANTMENT";
        case SpellSphere::Summoning: return "SUMMONING";
        case SpellSphere::Death: return "DEATH";
        case SpellSphere::Divination: return "DIVINATION";
    }
    return "";
}

enum class TargetType {
    Self = 0,
    AllyPc = 1,
    AllyNpc = 2,
    AllyGroup = 3,
    EnemyPc = 4,
    EnemyNpc = 5,
    ObjectInv = 6,
    ObjectWorld = 7,
    Corpse = 8,
};

/** Convert database string to TargetType enum */
inline std::optional<TargetType> target_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TargetType> lookup = {
        {"SELF", TargetType::Self},
        {"ALLY_PC", TargetType::AllyPc},
        {"ALLY_NPC", TargetType::AllyNpc},
        {"ALLY_GROUP", TargetType::AllyGroup},
        {"ENEMY_PC", TargetType::EnemyPc},
        {"ENEMY_NPC", TargetType::EnemyNpc},
        {"OBJECT_INV", TargetType::ObjectInv},
        {"OBJECT_WORLD", TargetType::ObjectWorld},
        {"CORPSE", TargetType::Corpse},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TargetType enum to database string */
inline std::string_view target_type_to_db(TargetType e) {
    switch (e) {
        case TargetType::Self: return "SELF";
        case TargetType::AllyPc: return "ALLY_PC";
        case TargetType::AllyNpc: return "ALLY_NPC";
        case TargetType::AllyGroup: return "ALLY_GROUP";
        case TargetType::EnemyPc: return "ENEMY_PC";
        case TargetType::EnemyNpc: return "ENEMY_NPC";
        case TargetType::ObjectInv: return "OBJECT_INV";
        case TargetType::ObjectWorld: return "OBJECT_WORLD";
        case TargetType::Corpse: return "CORPSE";
    }
    return "";
}

enum class TargetScope {
    Single = 0,
    Room = 1,
    Group = 2,
    Area = 3,
    Chain = 4,
    Cone = 5,
    Line = 6,
    Self = 7,
};

/** Convert database string to TargetScope enum */
inline std::optional<TargetScope> target_scope_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TargetScope> lookup = {
        {"SINGLE", TargetScope::Single},
        {"ROOM", TargetScope::Room},
        {"GROUP", TargetScope::Group},
        {"AREA", TargetScope::Area},
        {"CHAIN", TargetScope::Chain},
        {"CONE", TargetScope::Cone},
        {"LINE", TargetScope::Line},
        {"SELF", TargetScope::Self},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TargetScope enum to database string */
inline std::string_view target_scope_to_db(TargetScope e) {
    switch (e) {
        case TargetScope::Single: return "SINGLE";
        case TargetScope::Room: return "ROOM";
        case TargetScope::Group: return "GROUP";
        case TargetScope::Area: return "AREA";
        case TargetScope::Chain: return "CHAIN";
        case TargetScope::Cone: return "CONE";
        case TargetScope::Line: return "LINE";
        case TargetScope::Self: return "SELF";
    }
    return "";
}

enum class SaveType {
    Spell = 0,
    Poison = 1,
    Breath = 2,
    Paralysis = 3,
    Wand = 4,
    Rod = 5,
    Petrification = 6,
};

/** Convert database string to SaveType enum */
inline std::optional<SaveType> save_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SaveType> lookup = {
        {"SPELL", SaveType::Spell},
        {"POISON", SaveType::Poison},
        {"BREATH", SaveType::Breath},
        {"PARALYSIS", SaveType::Paralysis},
        {"WAND", SaveType::Wand},
        {"ROD", SaveType::Rod},
        {"PETRIFICATION", SaveType::Petrification},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SaveType enum to database string */
inline std::string_view save_type_to_db(SaveType e) {
    switch (e) {
        case SaveType::Spell: return "SPELL";
        case SaveType::Poison: return "POISON";
        case SaveType::Breath: return "BREATH";
        case SaveType::Paralysis: return "PARALYSIS";
        case SaveType::Wand: return "WAND";
        case SaveType::Rod: return "ROD";
        case SaveType::Petrification: return "PETRIFICATION";
    }
    return "";
}

enum class SaveResult {
    None = 0,
    Half = 1,
    Negate = 2,
    Reduce25 = 3,
    Custom = 4,
};

/** Convert database string to SaveResult enum */
inline std::optional<SaveResult> save_result_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SaveResult> lookup = {
        {"NONE", SaveResult::None},
        {"HALF", SaveResult::Half},
        {"NEGATE", SaveResult::Negate},
        {"REDUCE25", SaveResult::Reduce25},
        {"CUSTOM", SaveResult::Custom},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SaveResult enum to database string */
inline std::string_view save_result_to_db(SaveResult e) {
    switch (e) {
        case SaveResult::None: return "NONE";
        case SaveResult::Half: return "HALF";
        case SaveResult::Negate: return "NEGATE";
        case SaveResult::Reduce25: return "REDUCE25";
        case SaveResult::Custom: return "CUSTOM";
    }
    return "";
}

enum class StackingRule {
    Refresh = 0,
    Stack = 1,
    Ignore = 2,
    MaxOnly = 3,
};

/** Convert database string to StackingRule enum */
inline std::optional<StackingRule> stacking_rule_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, StackingRule> lookup = {
        {"REFRESH", StackingRule::Refresh},
        {"STACK", StackingRule::Stack},
        {"IGNORE", StackingRule::Ignore},
        {"MAX_ONLY", StackingRule::MaxOnly},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert StackingRule enum to database string */
inline std::string_view stacking_rule_to_db(StackingRule e) {
    switch (e) {
        case StackingRule::Refresh: return "REFRESH";
        case StackingRule::Stack: return "STACK";
        case StackingRule::Ignore: return "IGNORE";
        case StackingRule::MaxOnly: return "MAX_ONLY";
    }
    return "";
}

// ============================================================================
// Shop System
// ============================================================================

enum class ShopFlag {
    WillFight = 0,
    UsesBank = 1,
    WillBankMoney = 2,
    WillStartFight = 3,
};

/** Convert database string to ShopFlag enum */
inline std::optional<ShopFlag> shop_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ShopFlag> lookup = {
        {"WILL_FIGHT", ShopFlag::WillFight},
        {"USES_BANK", ShopFlag::UsesBank},
        {"WILL_BANK_MONEY", ShopFlag::WillBankMoney},
        {"WILL_START_FIGHT", ShopFlag::WillStartFight},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ShopFlag enum to database string */
inline std::string_view shop_flag_to_db(ShopFlag e) {
    switch (e) {
        case ShopFlag::WillFight: return "WILL_FIGHT";
        case ShopFlag::UsesBank: return "USES_BANK";
        case ShopFlag::WillBankMoney: return "WILL_BANK_MONEY";
        case ShopFlag::WillStartFight: return "WILL_START_FIGHT";
    }
    return "";
}

enum class ShopTradesWith {
    Alignment = 0,
    Race = 1,
    Class = 2,
    TradeNogood = 3,
    TradeNoevil = 4,
    TradeNoneutral = 5,
    TradeNocleric = 6,
    TradeNothief = 7,
    TradeNowarrior = 8,
};

/** Convert database string to ShopTradesWith enum */
inline std::optional<ShopTradesWith> shop_trades_with_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ShopTradesWith> lookup = {
        {"ALIGNMENT", ShopTradesWith::Alignment},
        {"RACE", ShopTradesWith::Race},
        {"CLASS", ShopTradesWith::Class},
        {"TRADE_NOGOOD", ShopTradesWith::TradeNogood},
        {"TRADE_NOEVIL", ShopTradesWith::TradeNoevil},
        {"TRADE_NONEUTRAL", ShopTradesWith::TradeNoneutral},
        {"TRADE_NOCLERIC", ShopTradesWith::TradeNocleric},
        {"TRADE_NOTHIEF", ShopTradesWith::TradeNothief},
        {"TRADE_NOWARRIOR", ShopTradesWith::TradeNowarrior},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ShopTradesWith enum to database string */
inline std::string_view shop_trades_with_to_db(ShopTradesWith e) {
    switch (e) {
        case ShopTradesWith::Alignment: return "ALIGNMENT";
        case ShopTradesWith::Race: return "RACE";
        case ShopTradesWith::Class: return "CLASS";
        case ShopTradesWith::TradeNogood: return "TRADE_NOGOOD";
        case ShopTradesWith::TradeNoevil: return "TRADE_NOEVIL";
        case ShopTradesWith::TradeNoneutral: return "TRADE_NONEUTRAL";
        case ShopTradesWith::TradeNocleric: return "TRADE_NOCLERIC";
        case ShopTradesWith::TradeNothief: return "TRADE_NOTHIEF";
        case ShopTradesWith::TradeNowarrior: return "TRADE_NOWARRIOR";
    }
    return "";
}

// ============================================================================
// Zone System
// ============================================================================

enum class Climate {
    None = 0,
    Semiarid = 1,
    Arid = 2,
    Oceanic = 3,
    Temperate = 4,
    Subtropical = 5,
    Tropical = 6,
    Subarctic = 7,
    Arctic = 8,
    Alpine = 9,
};

/** Convert database string to Climate enum */
inline std::optional<Climate> climate_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Climate> lookup = {
        {"NONE", Climate::None},
        {"SEMIARID", Climate::Semiarid},
        {"ARID", Climate::Arid},
        {"OCEANIC", Climate::Oceanic},
        {"TEMPERATE", Climate::Temperate},
        {"SUBTROPICAL", Climate::Subtropical},
        {"TROPICAL", Climate::Tropical},
        {"SUBARCTIC", Climate::Subarctic},
        {"ARCTIC", Climate::Arctic},
        {"ALPINE", Climate::Alpine},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Climate enum to database string */
inline std::string_view climate_to_db(Climate e) {
    switch (e) {
        case Climate::None: return "NONE";
        case Climate::Semiarid: return "SEMIARID";
        case Climate::Arid: return "ARID";
        case Climate::Oceanic: return "OCEANIC";
        case Climate::Temperate: return "TEMPERATE";
        case Climate::Subtropical: return "SUBTROPICAL";
        case Climate::Tropical: return "TROPICAL";
        case Climate::Subarctic: return "SUBARCTIC";
        case Climate::Arctic: return "ARCTIC";
        case Climate::Alpine: return "ALPINE";
    }
    return "";
}

enum class Hemisphere {
    Northwest = 0,
    Northeast = 1,
    Southwest = 2,
    Southeast = 3,
};

/** Convert database string to Hemisphere enum */
inline std::optional<Hemisphere> hemisphere_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, Hemisphere> lookup = {
        {"NORTHWEST", Hemisphere::Northwest},
        {"NORTHEAST", Hemisphere::Northeast},
        {"SOUTHWEST", Hemisphere::Southwest},
        {"SOUTHEAST", Hemisphere::Southeast},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert Hemisphere enum to database string */
inline std::string_view hemisphere_to_db(Hemisphere e) {
    switch (e) {
        case Hemisphere::Northwest: return "NORTHWEST";
        case Hemisphere::Northeast: return "NORTHEAST";
        case Hemisphere::Southwest: return "SOUTHWEST";
        case Hemisphere::Southeast: return "SOUTHEAST";
    }
    return "";
}

enum class ResetMode {
    Never = 0,
    Empty = 1,
    Normal = 2,
};

/** Convert database string to ResetMode enum */
inline std::optional<ResetMode> reset_mode_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ResetMode> lookup = {
        {"NEVER", ResetMode::Never},
        {"EMPTY", ResetMode::Empty},
        {"NORMAL", ResetMode::Normal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ResetMode enum to database string */
inline std::string_view reset_mode_to_db(ResetMode e) {
    switch (e) {
        case ResetMode::Never: return "NEVER";
        case ResetMode::Empty: return "EMPTY";
        case ResetMode::Normal: return "NORMAL";
    }
    return "";
}

// ============================================================================
// Script System
// ============================================================================

enum class ScriptType {
    Mob = 0,
    Object = 1,
    World = 2,
};

/** Convert database string to ScriptType enum */
inline std::optional<ScriptType> script_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ScriptType> lookup = {
        {"MOB", ScriptType::Mob},
        {"OBJECT", ScriptType::Object},
        {"WORLD", ScriptType::World},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ScriptType enum to database string */
inline std::string_view script_type_to_db(ScriptType e) {
    switch (e) {
        case ScriptType::Mob: return "MOB";
        case ScriptType::Object: return "OBJECT";
        case ScriptType::World: return "WORLD";
    }
    return "";
}

enum class TriggerFlag {
    Global = 0,
    Random = 1,
    Command = 2,
    Load = 3,
    Cast = 4,
    Leave = 5,
    Time = 6,
    Speech = 7,
    Act = 8,
    Death = 9,
    Greet = 10,
    GreetAll = 11,
    Entry = 12,
    Receive = 13,
    Fight = 14,
    HitPercent = 15,
    Bribe = 16,
    Memory = 17,
    Door = 18,
    SpeechTo = 19,
    Look = 20,
    Auto = 21,
    Attack = 22,
    Defend = 23,
    Timer = 24,
    Get = 25,
    Drop = 26,
    Give = 27,
    Wear = 28,
    Remove = 29,
    Use = 30,
    Consume = 31,
    Reset = 32,
    Preentry = 33,
    Postentry = 34,
};

/** Convert database string to TriggerFlag enum */
inline std::optional<TriggerFlag> trigger_flag_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, TriggerFlag> lookup = {
        {"GLOBAL", TriggerFlag::Global},
        {"RANDOM", TriggerFlag::Random},
        {"COMMAND", TriggerFlag::Command},
        {"LOAD", TriggerFlag::Load},
        {"CAST", TriggerFlag::Cast},
        {"LEAVE", TriggerFlag::Leave},
        {"TIME", TriggerFlag::Time},
        {"SPEECH", TriggerFlag::Speech},
        {"ACT", TriggerFlag::Act},
        {"DEATH", TriggerFlag::Death},
        {"GREET", TriggerFlag::Greet},
        {"GREET_ALL", TriggerFlag::GreetAll},
        {"ENTRY", TriggerFlag::Entry},
        {"RECEIVE", TriggerFlag::Receive},
        {"FIGHT", TriggerFlag::Fight},
        {"HIT_PERCENT", TriggerFlag::HitPercent},
        {"BRIBE", TriggerFlag::Bribe},
        {"MEMORY", TriggerFlag::Memory},
        {"DOOR", TriggerFlag::Door},
        {"SPEECH_TO", TriggerFlag::SpeechTo},
        {"LOOK", TriggerFlag::Look},
        {"AUTO", TriggerFlag::Auto},
        {"ATTACK", TriggerFlag::Attack},
        {"DEFEND", TriggerFlag::Defend},
        {"TIMER", TriggerFlag::Timer},
        {"GET", TriggerFlag::Get},
        {"DROP", TriggerFlag::Drop},
        {"GIVE", TriggerFlag::Give},
        {"WEAR", TriggerFlag::Wear},
        {"REMOVE", TriggerFlag::Remove},
        {"USE", TriggerFlag::Use},
        {"CONSUME", TriggerFlag::Consume},
        {"RESET", TriggerFlag::Reset},
        {"PREENTRY", TriggerFlag::Preentry},
        {"POSTENTRY", TriggerFlag::Postentry},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert TriggerFlag enum to database string */
inline std::string_view trigger_flag_to_db(TriggerFlag e) {
    switch (e) {
        case TriggerFlag::Global: return "GLOBAL";
        case TriggerFlag::Random: return "RANDOM";
        case TriggerFlag::Command: return "COMMAND";
        case TriggerFlag::Load: return "LOAD";
        case TriggerFlag::Cast: return "CAST";
        case TriggerFlag::Leave: return "LEAVE";
        case TriggerFlag::Time: return "TIME";
        case TriggerFlag::Speech: return "SPEECH";
        case TriggerFlag::Act: return "ACT";
        case TriggerFlag::Death: return "DEATH";
        case TriggerFlag::Greet: return "GREET";
        case TriggerFlag::GreetAll: return "GREET_ALL";
        case TriggerFlag::Entry: return "ENTRY";
        case TriggerFlag::Receive: return "RECEIVE";
        case TriggerFlag::Fight: return "FIGHT";
        case TriggerFlag::HitPercent: return "HIT_PERCENT";
        case TriggerFlag::Bribe: return "BRIBE";
        case TriggerFlag::Memory: return "MEMORY";
        case TriggerFlag::Door: return "DOOR";
        case TriggerFlag::SpeechTo: return "SPEECH_TO";
        case TriggerFlag::Look: return "LOOK";
        case TriggerFlag::Auto: return "AUTO";
        case TriggerFlag::Attack: return "ATTACK";
        case TriggerFlag::Defend: return "DEFEND";
        case TriggerFlag::Timer: return "TIMER";
        case TriggerFlag::Get: return "GET";
        case TriggerFlag::Drop: return "DROP";
        case TriggerFlag::Give: return "GIVE";
        case TriggerFlag::Wear: return "WEAR";
        case TriggerFlag::Remove: return "REMOVE";
        case TriggerFlag::Use: return "USE";
        case TriggerFlag::Consume: return "CONSUME";
        case TriggerFlag::Reset: return "RESET";
        case TriggerFlag::Preentry: return "PREENTRY";
        case TriggerFlag::Postentry: return "POSTENTRY";
    }
    return "";
}

// ============================================================================
// User System
// ============================================================================

enum class UserRole {
    Player = 0,
    Immortal = 1,
    Builder = 2,
    HeadBuilder = 3,
    Coder = 4,
    God = 5,
};

/** Convert database string to UserRole enum */
inline std::optional<UserRole> user_role_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, UserRole> lookup = {
        {"PLAYER", UserRole::Player},
        {"IMMORTAL", UserRole::Immortal},
        {"BUILDER", UserRole::Builder},
        {"HEAD_BUILDER", UserRole::HeadBuilder},
        {"CODER", UserRole::Coder},
        {"GOD", UserRole::God},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert UserRole enum to database string */
inline std::string_view user_role_to_db(UserRole e) {
    switch (e) {
        case UserRole::Player: return "PLAYER";
        case UserRole::Immortal: return "IMMORTAL";
        case UserRole::Builder: return "BUILDER";
        case UserRole::HeadBuilder: return "HEAD_BUILDER";
        case UserRole::Coder: return "CODER";
        case UserRole::God: return "GOD";
    }
    return "";
}

enum class GrantResourceType {
    Zone = 0,
    Mob = 1,
    Object = 2,
    Shop = 3,
};

/** Convert database string to GrantResourceType enum */
inline std::optional<GrantResourceType> grant_resource_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, GrantResourceType> lookup = {
        {"ZONE", GrantResourceType::Zone},
        {"MOB", GrantResourceType::Mob},
        {"OBJECT", GrantResourceType::Object},
        {"SHOP", GrantResourceType::Shop},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert GrantResourceType enum to database string */
inline std::string_view grant_resource_type_to_db(GrantResourceType e) {
    switch (e) {
        case GrantResourceType::Zone: return "ZONE";
        case GrantResourceType::Mob: return "MOB";
        case GrantResourceType::Object: return "OBJECT";
        case GrantResourceType::Shop: return "SHOP";
    }
    return "";
}

enum class GrantPermission {
    Read = 0,
    Write = 1,
    Delete = 2,
    Admin = 3,
};

/** Convert database string to GrantPermission enum */
inline std::optional<GrantPermission> grant_permission_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, GrantPermission> lookup = {
        {"READ", GrantPermission::Read},
        {"WRITE", GrantPermission::Write},
        {"DELETE", GrantPermission::Delete},
        {"ADMIN", GrantPermission::Admin},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert GrantPermission enum to database string */
inline std::string_view grant_permission_to_db(GrantPermission e) {
    switch (e) {
        case GrantPermission::Read: return "READ";
        case GrantPermission::Write: return "WRITE";
        case GrantPermission::Delete: return "DELETE";
        case GrantPermission::Admin: return "ADMIN";
    }
    return "";
}

// ============================================================================
// Configuration
// ============================================================================

enum class ConfigValueType {
    String = 0,
    Int = 1,
    Float = 2,
    Bool = 3,
    Json = 4,
};

/** Convert database string to ConfigValueType enum */
inline std::optional<ConfigValueType> config_value_type_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ConfigValueType> lookup = {
        {"STRING", ConfigValueType::String},
        {"INT", ConfigValueType::Int},
        {"FLOAT", ConfigValueType::Float},
        {"BOOL", ConfigValueType::Bool},
        {"JSON", ConfigValueType::Json},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ConfigValueType enum to database string */
inline std::string_view config_value_type_to_db(ConfigValueType e) {
    switch (e) {
        case ConfigValueType::String: return "STRING";
        case ConfigValueType::Int: return "INT";
        case ConfigValueType::Float: return "FLOAT";
        case ConfigValueType::Bool: return "BOOL";
        case ConfigValueType::Json: return "JSON";
    }
    return "";
}

enum class SystemTextCategory {
    Login = 0,
    System = 1,
    Combat = 2,
    Immortal = 3,
};

/** Convert database string to SystemTextCategory enum */
inline std::optional<SystemTextCategory> system_text_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, SystemTextCategory> lookup = {
        {"LOGIN", SystemTextCategory::Login},
        {"SYSTEM", SystemTextCategory::System},
        {"COMBAT", SystemTextCategory::Combat},
        {"IMMORTAL", SystemTextCategory::Immortal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert SystemTextCategory enum to database string */
inline std::string_view system_text_category_to_db(SystemTextCategory e) {
    switch (e) {
        case SystemTextCategory::Login: return "LOGIN";
        case SystemTextCategory::System: return "SYSTEM";
        case SystemTextCategory::Combat: return "COMBAT";
        case SystemTextCategory::Immortal: return "IMMORTAL";
    }
    return "";
}

enum class LoginStage {
    WelcomeBanner = 0,
    UsernamePrompt = 1,
    PasswordPrompt = 2,
    InvalidLogin = 3,
    TooManyAttempts = 4,
    CharacterSelect = 5,
    CreateNamePrompt = 6,
    CreatePassword = 7,
    ConfirmPassword = 8,
    SelectClass = 9,
    SelectRace = 10,
    CreationComplete = 11,
    ReconnectMessage = 12,
};

/** Convert database string to LoginStage enum */
inline std::optional<LoginStage> login_stage_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, LoginStage> lookup = {
        {"WELCOME_BANNER", LoginStage::WelcomeBanner},
        {"USERNAME_PROMPT", LoginStage::UsernamePrompt},
        {"PASSWORD_PROMPT", LoginStage::PasswordPrompt},
        {"INVALID_LOGIN", LoginStage::InvalidLogin},
        {"TOO_MANY_ATTEMPTS", LoginStage::TooManyAttempts},
        {"CHARACTER_SELECT", LoginStage::CharacterSelect},
        {"CREATE_NAME_PROMPT", LoginStage::CreateNamePrompt},
        {"CREATE_PASSWORD", LoginStage::CreatePassword},
        {"CONFIRM_PASSWORD", LoginStage::ConfirmPassword},
        {"SELECT_CLASS", LoginStage::SelectClass},
        {"SELECT_RACE", LoginStage::SelectRace},
        {"CREATION_COMPLETE", LoginStage::CreationComplete},
        {"RECONNECT_MESSAGE", LoginStage::ReconnectMessage},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert LoginStage enum to database string */
inline std::string_view login_stage_to_db(LoginStage e) {
    switch (e) {
        case LoginStage::WelcomeBanner: return "WELCOME_BANNER";
        case LoginStage::UsernamePrompt: return "USERNAME_PROMPT";
        case LoginStage::PasswordPrompt: return "PASSWORD_PROMPT";
        case LoginStage::InvalidLogin: return "INVALID_LOGIN";
        case LoginStage::TooManyAttempts: return "TOO_MANY_ATTEMPTS";
        case LoginStage::CharacterSelect: return "CHARACTER_SELECT";
        case LoginStage::CreateNamePrompt: return "CREATE_NAME_PROMPT";
        case LoginStage::CreatePassword: return "CREATE_PASSWORD";
        case LoginStage::ConfirmPassword: return "CONFIRM_PASSWORD";
        case LoginStage::SelectClass: return "SELECT_CLASS";
        case LoginStage::SelectRace: return "SELECT_RACE";
        case LoginStage::CreationComplete: return "CREATION_COMPLETE";
        case LoginStage::ReconnectMessage: return "RECONNECT_MESSAGE";
    }
    return "";
}

enum class CommandCategory {
    Movement = 0,
    Combat = 1,
    Communication = 2,
    Object = 3,
    Information = 4,
    Social = 5,
    Admin = 6,
    Building = 7,
    System = 8,
    Clan = 9,
    Magic = 10,
    Skills = 11,
};

/** Convert database string to CommandCategory enum */
inline std::optional<CommandCategory> command_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, CommandCategory> lookup = {
        {"MOVEMENT", CommandCategory::Movement},
        {"COMBAT", CommandCategory::Combat},
        {"COMMUNICATION", CommandCategory::Communication},
        {"OBJECT", CommandCategory::Object},
        {"INFORMATION", CommandCategory::Information},
        {"SOCIAL", CommandCategory::Social},
        {"ADMIN", CommandCategory::Admin},
        {"BUILDING", CommandCategory::Building},
        {"SYSTEM", CommandCategory::System},
        {"CLAN", CommandCategory::Clan},
        {"MAGIC", CommandCategory::Magic},
        {"SKILLS", CommandCategory::Skills},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert CommandCategory enum to database string */
inline std::string_view command_category_to_db(CommandCategory e) {
    switch (e) {
        case CommandCategory::Movement: return "MOVEMENT";
        case CommandCategory::Combat: return "COMBAT";
        case CommandCategory::Communication: return "COMMUNICATION";
        case CommandCategory::Object: return "OBJECT";
        case CommandCategory::Information: return "INFORMATION";
        case CommandCategory::Social: return "SOCIAL";
        case CommandCategory::Admin: return "ADMIN";
        case CommandCategory::Building: return "BUILDING";
        case CommandCategory::System: return "SYSTEM";
        case CommandCategory::Clan: return "CLAN";
        case CommandCategory::Magic: return "MAGIC";
        case CommandCategory::Skills: return "SKILLS";
    }
    return "";
}

// ============================================================================
// Other Enums
// ============================================================================

enum class ToggleCategory {
    Display = 0,
    Combat = 1,
    Social = 2,
    Immortal = 3,
};

/** Convert database string to ToggleCategory enum */
inline std::optional<ToggleCategory> toggle_category_from_db(std::string_view s) {
    static const std::unordered_map<std::string_view, ToggleCategory> lookup = {
        {"DISPLAY", ToggleCategory::Display},
        {"COMBAT", ToggleCategory::Combat},
        {"SOCIAL", ToggleCategory::Social},
        {"IMMORTAL", ToggleCategory::Immortal},
    };
    auto it = lookup.find(s);
    return it != lookup.end() ? std::optional{it->second} : std::nullopt;
}

/** Convert ToggleCategory enum to database string */
inline std::string_view toggle_category_to_db(ToggleCategory e) {
    switch (e) {
        case ToggleCategory::Display: return "DISPLAY";
        case ToggleCategory::Combat: return "COMBAT";
        case ToggleCategory::Social: return "SOCIAL";
        case ToggleCategory::Immortal: return "IMMORTAL";
    }
    return "";
}

} // namespace db
